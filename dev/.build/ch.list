
.build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002c9 	.word	0x080002c9
 8000008:	080002cb 	.word	0x080002cb
 800000c:	080002ca 	.word	0x080002ca
 8000010:	080002ca 	.word	0x080002ca
 8000014:	080002ca 	.word	0x080002ca
 8000018:	080002ca 	.word	0x080002ca
 800001c:	080002ca 	.word	0x080002ca
 8000020:	080002ca 	.word	0x080002ca
 8000024:	080002ca 	.word	0x080002ca
 8000028:	080002ca 	.word	0x080002ca
 800002c:	080023a1 	.word	0x080023a1
 8000030:	080002ca 	.word	0x080002ca
 8000034:	080002ca 	.word	0x080002ca
 8000038:	080002ca 	.word	0x080002ca
 800003c:	080002ca 	.word	0x080002ca
 8000040:	080002ca 	.word	0x080002ca
 8000044:	080002ca 	.word	0x080002ca
 8000048:	080002ca 	.word	0x080002ca
 800004c:	080002ca 	.word	0x080002ca
 8000050:	080002ca 	.word	0x080002ca
 8000054:	080002ca 	.word	0x080002ca
 8000058:	080002ca 	.word	0x080002ca
 800005c:	080002ca 	.word	0x080002ca
 8000060:	080002ca 	.word	0x080002ca
 8000064:	080002ca 	.word	0x080002ca
 8000068:	080002ca 	.word	0x080002ca
 800006c:	080002ca 	.word	0x080002ca
 8000070:	080002ca 	.word	0x080002ca
 8000074:	080002ca 	.word	0x080002ca
 8000078:	080002ca 	.word	0x080002ca
 800007c:	080002ca 	.word	0x080002ca
 8000080:	080002ca 	.word	0x080002ca
 8000084:	080002ca 	.word	0x080002ca
 8000088:	080002ca 	.word	0x080002ca
 800008c:	080002ca 	.word	0x080002ca
 8000090:	080002ca 	.word	0x080002ca
 8000094:	080002ca 	.word	0x080002ca
 8000098:	080002ca 	.word	0x080002ca
 800009c:	080002ca 	.word	0x080002ca
 80000a0:	080002ca 	.word	0x080002ca
 80000a4:	080002ca 	.word	0x080002ca
 80000a8:	080002ca 	.word	0x080002ca
 80000ac:	080002ca 	.word	0x080002ca
 80000b0:	08001281 	.word	0x08001281
 80000b4:	080002ca 	.word	0x080002ca
 80000b8:	08001381 	.word	0x08001381
 80000bc:	080002ca 	.word	0x080002ca
 80000c0:	080002ca 	.word	0x080002ca
 80000c4:	080002ca 	.word	0x080002ca
 80000c8:	080002ca 	.word	0x080002ca
 80000cc:	080002ca 	.word	0x080002ca
 80000d0:	080002ca 	.word	0x080002ca
 80000d4:	080013b1 	.word	0x080013b1
 80000d8:	080002ca 	.word	0x080002ca
 80000dc:	080002ca 	.word	0x080002ca
 80000e0:	080002ca 	.word	0x080002ca
 80000e4:	080002ca 	.word	0x080002ca
 80000e8:	080002ca 	.word	0x080002ca
 80000ec:	080002ca 	.word	0x080002ca
 80000f0:	080002ca 	.word	0x080002ca
 80000f4:	080002ca 	.word	0x080002ca
 80000f8:	080002ca 	.word	0x080002ca
 80000fc:	080002ca 	.word	0x080002ca
 8000100:	080002ca 	.word	0x080002ca
 8000104:	080002ca 	.word	0x080002ca
 8000108:	080002ca 	.word	0x080002ca
 800010c:	080002ca 	.word	0x080002ca
 8000110:	080002ca 	.word	0x080002ca
 8000114:	080002ca 	.word	0x080002ca
 8000118:	080002ca 	.word	0x080002ca
 800011c:	080002ca 	.word	0x080002ca
 8000120:	080002ca 	.word	0x080002ca
 8000124:	080002ca 	.word	0x080002ca
 8000128:	080002ca 	.word	0x080002ca
 800012c:	080002ca 	.word	0x080002ca
 8000130:	080002ca 	.word	0x080002ca
 8000134:	080002ca 	.word	0x080002ca
 8000138:	080002ca 	.word	0x080002ca
 800013c:	080002ca 	.word	0x080002ca
 8000140:	080002ca 	.word	0x080002ca
 8000144:	080002ca 	.word	0x080002ca
 8000148:	080002ca 	.word	0x080002ca
 800014c:	080002ca 	.word	0x080002ca
 8000150:	080002ca 	.word	0x080002ca
 8000154:	080002ca 	.word	0x080002ca
 8000158:	080002ca 	.word	0x080002ca
 800015c:	080002ca 	.word	0x080002ca
 8000160:	080002ca 	.word	0x080002ca
 8000164:	080002ca 	.word	0x080002ca
 8000168:	080002ca 	.word	0x080002ca
 800016c:	080002ca 	.word	0x080002ca
 8000170:	080002ca 	.word	0x080002ca
 8000174:	080002ca 	.word	0x080002ca
 8000178:	080002ca 	.word	0x080002ca
 800017c:	080002ca 	.word	0x080002ca
 8000180:	080002ca 	.word	0x080002ca
 8000184:	080002ca 	.word	0x080002ca
 8000188:	080002ca 	.word	0x080002ca
 800018c:	080002ca 	.word	0x080002ca
 8000190:	080002ca 	.word	0x080002ca
 8000194:	080002ca 	.word	0x080002ca
 8000198:	080002ca 	.word	0x080002ca
 800019c:	080002ca 	.word	0x080002ca
 80001a0:	080002ca 	.word	0x080002ca
 80001a4:	080002ca 	.word	0x080002ca
 80001a8:	080002ca 	.word	0x080002ca
 80001ac:	080002ca 	.word	0x080002ca
 80001b0:	080002ca 	.word	0x080002ca
 80001b4:	080002ca 	.word	0x080002ca
 80001b8:	080002ca 	.word	0x080002ca
 80001bc:	080002ca 	.word	0x080002ca
 80001c0:	080002ca 	.word	0x080002ca
 80001c4:	080002ca 	.word	0x080002ca
 80001c8:	080002ca 	.word	0x080002ca
 80001cc:	080002ca 	.word	0x080002ca
 80001d0:	080002ca 	.word	0x080002ca
 80001d4:	080002ca 	.word	0x080002ca
 80001d8:	080002ca 	.word	0x080002ca
 80001dc:	080002ca 	.word	0x080002ca

Disassembly of section .text:

080001f0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001f0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001f2:	4827      	ldr	r0, [pc, #156]	; (8000290 <endfiniloop+0x4>)
                msr     MSP, r0
 80001f4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001f8:	4826      	ldr	r0, [pc, #152]	; (8000294 <endfiniloop+0x8>)
                msr     PSP, r0
 80001fa:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001fe:	4826      	ldr	r0, [pc, #152]	; (8000298 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 8000200:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 8000204:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000208:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 800020a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800020c:	f380 8814 	msr	CONTROL, r0
                isb
 8000210:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000214:	f000 fc04 	bl	8000a20 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000218:	f001 f9ca 	bl	80015b0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800021c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000220:	491e      	ldr	r1, [pc, #120]	; (800029c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000222:	4a1b      	ldr	r2, [pc, #108]	; (8000290 <endfiniloop+0x4>)

08000224 <msloop>:
msloop:
                cmp     r1, r2
 8000224:	4291      	cmp	r1, r2
                itt     lo
 8000226:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000228:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800022c:	e7fa      	bcc.n	8000224 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800022e:	491c      	ldr	r1, [pc, #112]	; (80002a0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000230:	4a18      	ldr	r2, [pc, #96]	; (8000294 <endfiniloop+0x8>)

08000232 <psloop>:
psloop:
                cmp     r1, r2
 8000232:	4291      	cmp	r1, r2
                itt     lo
 8000234:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000236:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800023a:	e7fa      	bcc.n	8000232 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800023c:	4919      	ldr	r1, [pc, #100]	; (80002a4 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800023e:	4a1a      	ldr	r2, [pc, #104]	; (80002a8 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000240:	4b1a      	ldr	r3, [pc, #104]	; (80002ac <endfiniloop+0x20>)

08000242 <dloop>:
dloop:
                cmp     r2, r3
 8000242:	429a      	cmp	r2, r3
                ittt    lo
 8000244:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800024e:	e7f8      	bcc.n	8000242 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000250:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000252:	4917      	ldr	r1, [pc, #92]	; (80002b0 <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000254:	4a17      	ldr	r2, [pc, #92]	; (80002b4 <endfiniloop+0x28>)

08000256 <bloop>:
bloop:
                cmp     r1, r2
 8000256:	4291      	cmp	r1, r2
                itt     lo
 8000258:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800025e:	e7fa      	bcc.n	8000256 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000260:	f000 fbf6 	bl	8000a50 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000264:	f000 fbe4 	bl	8000a30 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 8000268:	4c13      	ldr	r4, [pc, #76]	; (80002b8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800026a:	4d14      	ldr	r5, [pc, #80]	; (80002bc <endfiniloop+0x30>)

0800026c <initloop>:
initloop:
                cmp     r4, r5
 800026c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800026e:	da03      	bge.n	8000278 <endinitloop>
                ldr     r1, [r4], #4
 8000270:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000274:	4788      	blx	r1
                b       initloop
 8000276:	e7f9      	b.n	800026c <initloop>

08000278 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000278:	f002 fe4a 	bl	8002f10 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800027c:	4c10      	ldr	r4, [pc, #64]	; (80002c0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 800027e:	4d11      	ldr	r5, [pc, #68]	; (80002c4 <endfiniloop+0x38>)

08000280 <finiloop>:
finiloop:
                cmp     r4, r5
 8000280:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000282:	da03      	bge.n	800028c <endfiniloop>
                ldr     r1, [r4], #4
 8000284:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000288:	4788      	blx	r1
                b       finiloop
 800028a:	e7f9      	b.n	8000280 <finiloop>

0800028c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800028c:	f000 bbd8 	b.w	8000a40 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000290:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000294:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000298:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800029c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002a0:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 80002a4:	080037e0 	.word	0x080037e0
                ldr     r2, =_data_start
 80002a8:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002ac:	2000080c 	.word	0x2000080c
                ldr     r1, =_bss_start
 80002b0:	20000810 	.word	0x20000810
                ldr     r2, =_bss_end
 80002b4:	200012f0 	.word	0x200012f0
                ldr     r4, =__init_array_start
 80002b8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002bc:	080001e4 	.word	0x080001e4
                ldr     r4, =__fini_array_start
 80002c0:	080001e4 	.word	0x080001e4
                ldr     r5, =__fini_array_end
 80002c4:	080001e4 	.word	0x080001e4

080002c8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002c8:	e792      	b.n	80001f0 <_crt0_entry>

080002ca <NMI_Handler>:
Vector3F0:
Vector3F4:
Vector3F8:
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ca:	f000 f800 	bl	80002ce <_unhandled_exception>

080002ce <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002ce:	e7fe      	b.n	80002ce <_unhandled_exception>

080002d0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002d4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002d8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002da:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002e0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002e2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002e6:	4628      	mov	r0, r5
                blx     r4
 80002e8:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80002ea:	2000      	movs	r0, #0
                bl      chThdExit
 80002ec:	f001 fd68 	bl	8001dc0 <chThdExit>

080002f0 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002f0:	f001 fc56 	bl	8001ba0 <chSchDoReschedule>

080002f4 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002f4:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002f6:	e7fe      	b.n	80002f6 <_port_exit_from_isr+0x2>

080002f8 <__aeabi_uldivmod>:
 80002f8:	b953      	cbnz	r3, 8000310 <__aeabi_uldivmod+0x18>
 80002fa:	b94a      	cbnz	r2, 8000310 <__aeabi_uldivmod+0x18>
 80002fc:	2900      	cmp	r1, #0
 80002fe:	bf08      	it	eq
 8000300:	2800      	cmpeq	r0, #0
 8000302:	bf1c      	itt	ne
 8000304:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000308:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 800030c:	f000 b972 	b.w	80005f4 <__aeabi_idiv0>
 8000310:	f1ad 0c08 	sub.w	ip, sp, #8
 8000314:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000318:	f000 f806 	bl	8000328 <__udivmoddi4>
 800031c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000320:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000324:	b004      	add	sp, #16
 8000326:	4770      	bx	lr

08000328 <__udivmoddi4>:
 8000328:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800032c:	9e08      	ldr	r6, [sp, #32]
 800032e:	4604      	mov	r4, r0
 8000330:	4688      	mov	r8, r1
 8000332:	2b00      	cmp	r3, #0
 8000334:	d14b      	bne.n	80003ce <__udivmoddi4+0xa6>
 8000336:	428a      	cmp	r2, r1
 8000338:	4615      	mov	r5, r2
 800033a:	d967      	bls.n	800040c <__udivmoddi4+0xe4>
 800033c:	fab2 f282 	clz	r2, r2
 8000340:	b14a      	cbz	r2, 8000356 <__udivmoddi4+0x2e>
 8000342:	f1c2 0720 	rsb	r7, r2, #32
 8000346:	fa01 f302 	lsl.w	r3, r1, r2
 800034a:	fa20 f707 	lsr.w	r7, r0, r7
 800034e:	4095      	lsls	r5, r2
 8000350:	ea47 0803 	orr.w	r8, r7, r3
 8000354:	4094      	lsls	r4, r2
 8000356:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800035a:	0c23      	lsrs	r3, r4, #16
 800035c:	fbb8 f7fe 	udiv	r7, r8, lr
 8000360:	fa1f fc85 	uxth.w	ip, r5
 8000364:	fb0e 8817 	mls	r8, lr, r7, r8
 8000368:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800036c:	fb07 f10c 	mul.w	r1, r7, ip
 8000370:	4299      	cmp	r1, r3
 8000372:	d909      	bls.n	8000388 <__udivmoddi4+0x60>
 8000374:	18eb      	adds	r3, r5, r3
 8000376:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 800037a:	f080 811b 	bcs.w	80005b4 <__udivmoddi4+0x28c>
 800037e:	4299      	cmp	r1, r3
 8000380:	f240 8118 	bls.w	80005b4 <__udivmoddi4+0x28c>
 8000384:	3f02      	subs	r7, #2
 8000386:	442b      	add	r3, r5
 8000388:	1a5b      	subs	r3, r3, r1
 800038a:	b2a4      	uxth	r4, r4
 800038c:	fbb3 f0fe 	udiv	r0, r3, lr
 8000390:	fb0e 3310 	mls	r3, lr, r0, r3
 8000394:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000398:	fb00 fc0c 	mul.w	ip, r0, ip
 800039c:	45a4      	cmp	ip, r4
 800039e:	d909      	bls.n	80003b4 <__udivmoddi4+0x8c>
 80003a0:	192c      	adds	r4, r5, r4
 80003a2:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80003a6:	f080 8107 	bcs.w	80005b8 <__udivmoddi4+0x290>
 80003aa:	45a4      	cmp	ip, r4
 80003ac:	f240 8104 	bls.w	80005b8 <__udivmoddi4+0x290>
 80003b0:	3802      	subs	r0, #2
 80003b2:	442c      	add	r4, r5
 80003b4:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80003b8:	eba4 040c 	sub.w	r4, r4, ip
 80003bc:	2700      	movs	r7, #0
 80003be:	b11e      	cbz	r6, 80003c8 <__udivmoddi4+0xa0>
 80003c0:	40d4      	lsrs	r4, r2
 80003c2:	2300      	movs	r3, #0
 80003c4:	e9c6 4300 	strd	r4, r3, [r6]
 80003c8:	4639      	mov	r1, r7
 80003ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003ce:	428b      	cmp	r3, r1
 80003d0:	d909      	bls.n	80003e6 <__udivmoddi4+0xbe>
 80003d2:	2e00      	cmp	r6, #0
 80003d4:	f000 80eb 	beq.w	80005ae <__udivmoddi4+0x286>
 80003d8:	2700      	movs	r7, #0
 80003da:	e9c6 0100 	strd	r0, r1, [r6]
 80003de:	4638      	mov	r0, r7
 80003e0:	4639      	mov	r1, r7
 80003e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003e6:	fab3 f783 	clz	r7, r3
 80003ea:	2f00      	cmp	r7, #0
 80003ec:	d147      	bne.n	800047e <__udivmoddi4+0x156>
 80003ee:	428b      	cmp	r3, r1
 80003f0:	d302      	bcc.n	80003f8 <__udivmoddi4+0xd0>
 80003f2:	4282      	cmp	r2, r0
 80003f4:	f200 80fa 	bhi.w	80005ec <__udivmoddi4+0x2c4>
 80003f8:	1a84      	subs	r4, r0, r2
 80003fa:	eb61 0303 	sbc.w	r3, r1, r3
 80003fe:	2001      	movs	r0, #1
 8000400:	4698      	mov	r8, r3
 8000402:	2e00      	cmp	r6, #0
 8000404:	d0e0      	beq.n	80003c8 <__udivmoddi4+0xa0>
 8000406:	e9c6 4800 	strd	r4, r8, [r6]
 800040a:	e7dd      	b.n	80003c8 <__udivmoddi4+0xa0>
 800040c:	b902      	cbnz	r2, 8000410 <__udivmoddi4+0xe8>
 800040e:	deff      	udf	#255	; 0xff
 8000410:	fab2 f282 	clz	r2, r2
 8000414:	2a00      	cmp	r2, #0
 8000416:	f040 808f 	bne.w	8000538 <__udivmoddi4+0x210>
 800041a:	1b49      	subs	r1, r1, r5
 800041c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000420:	fa1f f885 	uxth.w	r8, r5
 8000424:	2701      	movs	r7, #1
 8000426:	fbb1 fcfe 	udiv	ip, r1, lr
 800042a:	0c23      	lsrs	r3, r4, #16
 800042c:	fb0e 111c 	mls	r1, lr, ip, r1
 8000430:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000434:	fb08 f10c 	mul.w	r1, r8, ip
 8000438:	4299      	cmp	r1, r3
 800043a:	d907      	bls.n	800044c <__udivmoddi4+0x124>
 800043c:	18eb      	adds	r3, r5, r3
 800043e:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 8000442:	d202      	bcs.n	800044a <__udivmoddi4+0x122>
 8000444:	4299      	cmp	r1, r3
 8000446:	f200 80cd 	bhi.w	80005e4 <__udivmoddi4+0x2bc>
 800044a:	4684      	mov	ip, r0
 800044c:	1a59      	subs	r1, r3, r1
 800044e:	b2a3      	uxth	r3, r4
 8000450:	fbb1 f0fe 	udiv	r0, r1, lr
 8000454:	fb0e 1410 	mls	r4, lr, r0, r1
 8000458:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 800045c:	fb08 f800 	mul.w	r8, r8, r0
 8000460:	45a0      	cmp	r8, r4
 8000462:	d907      	bls.n	8000474 <__udivmoddi4+0x14c>
 8000464:	192c      	adds	r4, r5, r4
 8000466:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800046a:	d202      	bcs.n	8000472 <__udivmoddi4+0x14a>
 800046c:	45a0      	cmp	r8, r4
 800046e:	f200 80b6 	bhi.w	80005de <__udivmoddi4+0x2b6>
 8000472:	4618      	mov	r0, r3
 8000474:	eba4 0408 	sub.w	r4, r4, r8
 8000478:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 800047c:	e79f      	b.n	80003be <__udivmoddi4+0x96>
 800047e:	f1c7 0c20 	rsb	ip, r7, #32
 8000482:	40bb      	lsls	r3, r7
 8000484:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000488:	ea4e 0e03 	orr.w	lr, lr, r3
 800048c:	fa01 f407 	lsl.w	r4, r1, r7
 8000490:	fa20 f50c 	lsr.w	r5, r0, ip
 8000494:	fa21 f30c 	lsr.w	r3, r1, ip
 8000498:	ea4f 481e 	mov.w	r8, lr, lsr #16
 800049c:	4325      	orrs	r5, r4
 800049e:	fbb3 f9f8 	udiv	r9, r3, r8
 80004a2:	0c2c      	lsrs	r4, r5, #16
 80004a4:	fb08 3319 	mls	r3, r8, r9, r3
 80004a8:	fa1f fa8e 	uxth.w	sl, lr
 80004ac:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 80004b0:	fb09 f40a 	mul.w	r4, r9, sl
 80004b4:	429c      	cmp	r4, r3
 80004b6:	fa02 f207 	lsl.w	r2, r2, r7
 80004ba:	fa00 f107 	lsl.w	r1, r0, r7
 80004be:	d90b      	bls.n	80004d8 <__udivmoddi4+0x1b0>
 80004c0:	eb1e 0303 	adds.w	r3, lr, r3
 80004c4:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 80004c8:	f080 8087 	bcs.w	80005da <__udivmoddi4+0x2b2>
 80004cc:	429c      	cmp	r4, r3
 80004ce:	f240 8084 	bls.w	80005da <__udivmoddi4+0x2b2>
 80004d2:	f1a9 0902 	sub.w	r9, r9, #2
 80004d6:	4473      	add	r3, lr
 80004d8:	1b1b      	subs	r3, r3, r4
 80004da:	b2ad      	uxth	r5, r5
 80004dc:	fbb3 f0f8 	udiv	r0, r3, r8
 80004e0:	fb08 3310 	mls	r3, r8, r0, r3
 80004e4:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 80004e8:	fb00 fa0a 	mul.w	sl, r0, sl
 80004ec:	45a2      	cmp	sl, r4
 80004ee:	d908      	bls.n	8000502 <__udivmoddi4+0x1da>
 80004f0:	eb1e 0404 	adds.w	r4, lr, r4
 80004f4:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80004f8:	d26b      	bcs.n	80005d2 <__udivmoddi4+0x2aa>
 80004fa:	45a2      	cmp	sl, r4
 80004fc:	d969      	bls.n	80005d2 <__udivmoddi4+0x2aa>
 80004fe:	3802      	subs	r0, #2
 8000500:	4474      	add	r4, lr
 8000502:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000506:	fba0 8902 	umull	r8, r9, r0, r2
 800050a:	eba4 040a 	sub.w	r4, r4, sl
 800050e:	454c      	cmp	r4, r9
 8000510:	46c2      	mov	sl, r8
 8000512:	464b      	mov	r3, r9
 8000514:	d354      	bcc.n	80005c0 <__udivmoddi4+0x298>
 8000516:	d051      	beq.n	80005bc <__udivmoddi4+0x294>
 8000518:	2e00      	cmp	r6, #0
 800051a:	d069      	beq.n	80005f0 <__udivmoddi4+0x2c8>
 800051c:	ebb1 050a 	subs.w	r5, r1, sl
 8000520:	eb64 0403 	sbc.w	r4, r4, r3
 8000524:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000528:	40fd      	lsrs	r5, r7
 800052a:	40fc      	lsrs	r4, r7
 800052c:	ea4c 0505 	orr.w	r5, ip, r5
 8000530:	e9c6 5400 	strd	r5, r4, [r6]
 8000534:	2700      	movs	r7, #0
 8000536:	e747      	b.n	80003c8 <__udivmoddi4+0xa0>
 8000538:	f1c2 0320 	rsb	r3, r2, #32
 800053c:	fa20 f703 	lsr.w	r7, r0, r3
 8000540:	4095      	lsls	r5, r2
 8000542:	fa01 f002 	lsl.w	r0, r1, r2
 8000546:	fa21 f303 	lsr.w	r3, r1, r3
 800054a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800054e:	4338      	orrs	r0, r7
 8000550:	0c01      	lsrs	r1, r0, #16
 8000552:	fbb3 f7fe 	udiv	r7, r3, lr
 8000556:	fa1f f885 	uxth.w	r8, r5
 800055a:	fb0e 3317 	mls	r3, lr, r7, r3
 800055e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000562:	fb07 f308 	mul.w	r3, r7, r8
 8000566:	428b      	cmp	r3, r1
 8000568:	fa04 f402 	lsl.w	r4, r4, r2
 800056c:	d907      	bls.n	800057e <__udivmoddi4+0x256>
 800056e:	1869      	adds	r1, r5, r1
 8000570:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 8000574:	d22f      	bcs.n	80005d6 <__udivmoddi4+0x2ae>
 8000576:	428b      	cmp	r3, r1
 8000578:	d92d      	bls.n	80005d6 <__udivmoddi4+0x2ae>
 800057a:	3f02      	subs	r7, #2
 800057c:	4429      	add	r1, r5
 800057e:	1acb      	subs	r3, r1, r3
 8000580:	b281      	uxth	r1, r0
 8000582:	fbb3 f0fe 	udiv	r0, r3, lr
 8000586:	fb0e 3310 	mls	r3, lr, r0, r3
 800058a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800058e:	fb00 f308 	mul.w	r3, r0, r8
 8000592:	428b      	cmp	r3, r1
 8000594:	d907      	bls.n	80005a6 <__udivmoddi4+0x27e>
 8000596:	1869      	adds	r1, r5, r1
 8000598:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 800059c:	d217      	bcs.n	80005ce <__udivmoddi4+0x2a6>
 800059e:	428b      	cmp	r3, r1
 80005a0:	d915      	bls.n	80005ce <__udivmoddi4+0x2a6>
 80005a2:	3802      	subs	r0, #2
 80005a4:	4429      	add	r1, r5
 80005a6:	1ac9      	subs	r1, r1, r3
 80005a8:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 80005ac:	e73b      	b.n	8000426 <__udivmoddi4+0xfe>
 80005ae:	4637      	mov	r7, r6
 80005b0:	4630      	mov	r0, r6
 80005b2:	e709      	b.n	80003c8 <__udivmoddi4+0xa0>
 80005b4:	4607      	mov	r7, r0
 80005b6:	e6e7      	b.n	8000388 <__udivmoddi4+0x60>
 80005b8:	4618      	mov	r0, r3
 80005ba:	e6fb      	b.n	80003b4 <__udivmoddi4+0x8c>
 80005bc:	4541      	cmp	r1, r8
 80005be:	d2ab      	bcs.n	8000518 <__udivmoddi4+0x1f0>
 80005c0:	ebb8 0a02 	subs.w	sl, r8, r2
 80005c4:	eb69 020e 	sbc.w	r2, r9, lr
 80005c8:	3801      	subs	r0, #1
 80005ca:	4613      	mov	r3, r2
 80005cc:	e7a4      	b.n	8000518 <__udivmoddi4+0x1f0>
 80005ce:	4660      	mov	r0, ip
 80005d0:	e7e9      	b.n	80005a6 <__udivmoddi4+0x27e>
 80005d2:	4618      	mov	r0, r3
 80005d4:	e795      	b.n	8000502 <__udivmoddi4+0x1da>
 80005d6:	4667      	mov	r7, ip
 80005d8:	e7d1      	b.n	800057e <__udivmoddi4+0x256>
 80005da:	4681      	mov	r9, r0
 80005dc:	e77c      	b.n	80004d8 <__udivmoddi4+0x1b0>
 80005de:	3802      	subs	r0, #2
 80005e0:	442c      	add	r4, r5
 80005e2:	e747      	b.n	8000474 <__udivmoddi4+0x14c>
 80005e4:	f1ac 0c02 	sub.w	ip, ip, #2
 80005e8:	442b      	add	r3, r5
 80005ea:	e72f      	b.n	800044c <__udivmoddi4+0x124>
 80005ec:	4638      	mov	r0, r7
 80005ee:	e708      	b.n	8000402 <__udivmoddi4+0xda>
 80005f0:	4637      	mov	r7, r6
 80005f2:	e6e9      	b.n	80003c8 <__udivmoddi4+0xa0>

080005f4 <__aeabi_idiv0>:
 80005f4:	4770      	bx	lr
 80005f6:	bf00      	nop

080005f8 <memcpy>:
 80005f8:	4684      	mov	ip, r0
 80005fa:	ea41 0300 	orr.w	r3, r1, r0
 80005fe:	f013 0303 	ands.w	r3, r3, #3
 8000602:	d16d      	bne.n	80006e0 <memcpy+0xe8>
 8000604:	3a40      	subs	r2, #64	; 0x40
 8000606:	d341      	bcc.n	800068c <memcpy+0x94>
 8000608:	f851 3b04 	ldr.w	r3, [r1], #4
 800060c:	f840 3b04 	str.w	r3, [r0], #4
 8000610:	f851 3b04 	ldr.w	r3, [r1], #4
 8000614:	f840 3b04 	str.w	r3, [r0], #4
 8000618:	f851 3b04 	ldr.w	r3, [r1], #4
 800061c:	f840 3b04 	str.w	r3, [r0], #4
 8000620:	f851 3b04 	ldr.w	r3, [r1], #4
 8000624:	f840 3b04 	str.w	r3, [r0], #4
 8000628:	f851 3b04 	ldr.w	r3, [r1], #4
 800062c:	f840 3b04 	str.w	r3, [r0], #4
 8000630:	f851 3b04 	ldr.w	r3, [r1], #4
 8000634:	f840 3b04 	str.w	r3, [r0], #4
 8000638:	f851 3b04 	ldr.w	r3, [r1], #4
 800063c:	f840 3b04 	str.w	r3, [r0], #4
 8000640:	f851 3b04 	ldr.w	r3, [r1], #4
 8000644:	f840 3b04 	str.w	r3, [r0], #4
 8000648:	f851 3b04 	ldr.w	r3, [r1], #4
 800064c:	f840 3b04 	str.w	r3, [r0], #4
 8000650:	f851 3b04 	ldr.w	r3, [r1], #4
 8000654:	f840 3b04 	str.w	r3, [r0], #4
 8000658:	f851 3b04 	ldr.w	r3, [r1], #4
 800065c:	f840 3b04 	str.w	r3, [r0], #4
 8000660:	f851 3b04 	ldr.w	r3, [r1], #4
 8000664:	f840 3b04 	str.w	r3, [r0], #4
 8000668:	f851 3b04 	ldr.w	r3, [r1], #4
 800066c:	f840 3b04 	str.w	r3, [r0], #4
 8000670:	f851 3b04 	ldr.w	r3, [r1], #4
 8000674:	f840 3b04 	str.w	r3, [r0], #4
 8000678:	f851 3b04 	ldr.w	r3, [r1], #4
 800067c:	f840 3b04 	str.w	r3, [r0], #4
 8000680:	f851 3b04 	ldr.w	r3, [r1], #4
 8000684:	f840 3b04 	str.w	r3, [r0], #4
 8000688:	3a40      	subs	r2, #64	; 0x40
 800068a:	d2bd      	bcs.n	8000608 <memcpy+0x10>
 800068c:	3230      	adds	r2, #48	; 0x30
 800068e:	d311      	bcc.n	80006b4 <memcpy+0xbc>
 8000690:	f851 3b04 	ldr.w	r3, [r1], #4
 8000694:	f840 3b04 	str.w	r3, [r0], #4
 8000698:	f851 3b04 	ldr.w	r3, [r1], #4
 800069c:	f840 3b04 	str.w	r3, [r0], #4
 80006a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80006a4:	f840 3b04 	str.w	r3, [r0], #4
 80006a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80006ac:	f840 3b04 	str.w	r3, [r0], #4
 80006b0:	3a10      	subs	r2, #16
 80006b2:	d2ed      	bcs.n	8000690 <memcpy+0x98>
 80006b4:	320c      	adds	r2, #12
 80006b6:	d305      	bcc.n	80006c4 <memcpy+0xcc>
 80006b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80006bc:	f840 3b04 	str.w	r3, [r0], #4
 80006c0:	3a04      	subs	r2, #4
 80006c2:	d2f9      	bcs.n	80006b8 <memcpy+0xc0>
 80006c4:	3204      	adds	r2, #4
 80006c6:	d008      	beq.n	80006da <memcpy+0xe2>
 80006c8:	07d2      	lsls	r2, r2, #31
 80006ca:	bf1c      	itt	ne
 80006cc:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80006d0:	f800 3b01 	strbne.w	r3, [r0], #1
 80006d4:	d301      	bcc.n	80006da <memcpy+0xe2>
 80006d6:	880b      	ldrh	r3, [r1, #0]
 80006d8:	8003      	strh	r3, [r0, #0]
 80006da:	4660      	mov	r0, ip
 80006dc:	4770      	bx	lr
 80006de:	bf00      	nop
 80006e0:	2a08      	cmp	r2, #8
 80006e2:	d313      	bcc.n	800070c <memcpy+0x114>
 80006e4:	078b      	lsls	r3, r1, #30
 80006e6:	d08d      	beq.n	8000604 <memcpy+0xc>
 80006e8:	f010 0303 	ands.w	r3, r0, #3
 80006ec:	d08a      	beq.n	8000604 <memcpy+0xc>
 80006ee:	f1c3 0304 	rsb	r3, r3, #4
 80006f2:	1ad2      	subs	r2, r2, r3
 80006f4:	07db      	lsls	r3, r3, #31
 80006f6:	bf1c      	itt	ne
 80006f8:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80006fc:	f800 3b01 	strbne.w	r3, [r0], #1
 8000700:	d380      	bcc.n	8000604 <memcpy+0xc>
 8000702:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000706:	f820 3b02 	strh.w	r3, [r0], #2
 800070a:	e77b      	b.n	8000604 <memcpy+0xc>
 800070c:	3a04      	subs	r2, #4
 800070e:	d3d9      	bcc.n	80006c4 <memcpy+0xcc>
 8000710:	3a01      	subs	r2, #1
 8000712:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000716:	f800 3b01 	strb.w	r3, [r0], #1
 800071a:	d2f9      	bcs.n	8000710 <memcpy+0x118>
 800071c:	780b      	ldrb	r3, [r1, #0]
 800071e:	7003      	strb	r3, [r0, #0]
 8000720:	784b      	ldrb	r3, [r1, #1]
 8000722:	7043      	strb	r3, [r0, #1]
 8000724:	788b      	ldrb	r3, [r1, #2]
 8000726:	7083      	strb	r3, [r0, #2]
 8000728:	4660      	mov	r0, ip
 800072a:	4770      	bx	lr
	...
 8000740:	eba2 0003 	sub.w	r0, r2, r3
 8000744:	4770      	bx	lr
 8000746:	bf00      	nop

08000748 <strcmp>:
 8000748:	7802      	ldrb	r2, [r0, #0]
 800074a:	780b      	ldrb	r3, [r1, #0]
 800074c:	2a01      	cmp	r2, #1
 800074e:	bf28      	it	cs
 8000750:	429a      	cmpcs	r2, r3
 8000752:	d1f5      	bne.n	8000740 <memcpy+0x148>
 8000754:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000758:	ea40 0401 	orr.w	r4, r0, r1
 800075c:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000760:	f06f 0c00 	mvn.w	ip, #0
 8000764:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000768:	b312      	cbz	r2, 80007b0 <strcmp+0x68>
 800076a:	ea80 0401 	eor.w	r4, r0, r1
 800076e:	f014 0f07 	tst.w	r4, #7
 8000772:	d16a      	bne.n	800084a <strcmp+0x102>
 8000774:	f000 0407 	and.w	r4, r0, #7
 8000778:	f020 0007 	bic.w	r0, r0, #7
 800077c:	f004 0503 	and.w	r5, r4, #3
 8000780:	f021 0107 	bic.w	r1, r1, #7
 8000784:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000788:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 800078c:	f014 0f04 	tst.w	r4, #4
 8000790:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000794:	fa0c f405 	lsl.w	r4, ip, r5
 8000798:	ea62 0204 	orn	r2, r2, r4
 800079c:	ea66 0604 	orn	r6, r6, r4
 80007a0:	d00a      	beq.n	80007b8 <strcmp+0x70>
 80007a2:	ea63 0304 	orn	r3, r3, r4
 80007a6:	4662      	mov	r2, ip
 80007a8:	ea67 0704 	orn	r7, r7, r4
 80007ac:	4666      	mov	r6, ip
 80007ae:	e003      	b.n	80007b8 <strcmp+0x70>
 80007b0:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80007b4:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80007b8:	fa82 f54c 	uadd8	r5, r2, ip
 80007bc:	ea82 0406 	eor.w	r4, r2, r6
 80007c0:	faa4 f48c 	sel	r4, r4, ip
 80007c4:	bb6c      	cbnz	r4, 8000822 <strcmp+0xda>
 80007c6:	fa83 f54c 	uadd8	r5, r3, ip
 80007ca:	ea83 0507 	eor.w	r5, r3, r7
 80007ce:	faa5 f58c 	sel	r5, r5, ip
 80007d2:	b995      	cbnz	r5, 80007fa <strcmp+0xb2>
 80007d4:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 80007d8:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 80007dc:	fa82 f54c 	uadd8	r5, r2, ip
 80007e0:	ea82 0406 	eor.w	r4, r2, r6
 80007e4:	faa4 f48c 	sel	r4, r4, ip
 80007e8:	fa83 f54c 	uadd8	r5, r3, ip
 80007ec:	ea83 0507 	eor.w	r5, r3, r7
 80007f0:	faa5 f58c 	sel	r5, r5, ip
 80007f4:	4325      	orrs	r5, r4
 80007f6:	d0db      	beq.n	80007b0 <strcmp+0x68>
 80007f8:	b99c      	cbnz	r4, 8000822 <strcmp+0xda>
 80007fa:	ba2d      	rev	r5, r5
 80007fc:	fab5 f485 	clz	r4, r5
 8000800:	f024 0407 	bic.w	r4, r4, #7
 8000804:	fa27 f104 	lsr.w	r1, r7, r4
 8000808:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800080c:	fa23 f304 	lsr.w	r3, r3, r4
 8000810:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000814:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000818:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800081c:	eba0 0001 	sub.w	r0, r0, r1
 8000820:	4770      	bx	lr
 8000822:	ba24      	rev	r4, r4
 8000824:	fab4 f484 	clz	r4, r4
 8000828:	f024 0407 	bic.w	r4, r4, #7
 800082c:	fa26 f104 	lsr.w	r1, r6, r4
 8000830:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000834:	fa22 f204 	lsr.w	r2, r2, r4
 8000838:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800083c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000840:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000844:	eba0 0001 	sub.w	r0, r0, r1
 8000848:	4770      	bx	lr
 800084a:	f014 0f03 	tst.w	r4, #3
 800084e:	d13c      	bne.n	80008ca <strcmp+0x182>
 8000850:	f010 0403 	ands.w	r4, r0, #3
 8000854:	d128      	bne.n	80008a8 <strcmp+0x160>
 8000856:	f850 2b08 	ldr.w	r2, [r0], #8
 800085a:	f851 3b08 	ldr.w	r3, [r1], #8
 800085e:	fa82 f54c 	uadd8	r5, r2, ip
 8000862:	ea82 0503 	eor.w	r5, r2, r3
 8000866:	faa5 f58c 	sel	r5, r5, ip
 800086a:	b95d      	cbnz	r5, 8000884 <strcmp+0x13c>
 800086c:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000870:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000874:	fa82 f54c 	uadd8	r5, r2, ip
 8000878:	ea82 0503 	eor.w	r5, r2, r3
 800087c:	faa5 f58c 	sel	r5, r5, ip
 8000880:	2d00      	cmp	r5, #0
 8000882:	d0e8      	beq.n	8000856 <strcmp+0x10e>
 8000884:	ba2d      	rev	r5, r5
 8000886:	fab5 f485 	clz	r4, r5
 800088a:	f024 0407 	bic.w	r4, r4, #7
 800088e:	fa23 f104 	lsr.w	r1, r3, r4
 8000892:	fa22 f204 	lsr.w	r2, r2, r4
 8000896:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800089a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800089e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80008a2:	eba0 0001 	sub.w	r0, r0, r1
 80008a6:	4770      	bx	lr
 80008a8:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80008ac:	f020 0003 	bic.w	r0, r0, #3
 80008b0:	f850 2b08 	ldr.w	r2, [r0], #8
 80008b4:	f021 0103 	bic.w	r1, r1, #3
 80008b8:	f851 3b08 	ldr.w	r3, [r1], #8
 80008bc:	fa0c f404 	lsl.w	r4, ip, r4
 80008c0:	ea62 0204 	orn	r2, r2, r4
 80008c4:	ea63 0304 	orn	r3, r3, r4
 80008c8:	e7c9      	b.n	800085e <strcmp+0x116>
 80008ca:	f010 0403 	ands.w	r4, r0, #3
 80008ce:	d01a      	beq.n	8000906 <strcmp+0x1be>
 80008d0:	eba1 0104 	sub.w	r1, r1, r4
 80008d4:	f020 0003 	bic.w	r0, r0, #3
 80008d8:	07e4      	lsls	r4, r4, #31
 80008da:	f850 2b04 	ldr.w	r2, [r0], #4
 80008de:	d006      	beq.n	80008ee <strcmp+0x1a6>
 80008e0:	d20f      	bcs.n	8000902 <strcmp+0x1ba>
 80008e2:	788b      	ldrb	r3, [r1, #2]
 80008e4:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 80008e8:	1ae4      	subs	r4, r4, r3
 80008ea:	d106      	bne.n	80008fa <strcmp+0x1b2>
 80008ec:	b12b      	cbz	r3, 80008fa <strcmp+0x1b2>
 80008ee:	78cb      	ldrb	r3, [r1, #3]
 80008f0:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 80008f4:	1ae4      	subs	r4, r4, r3
 80008f6:	d100      	bne.n	80008fa <strcmp+0x1b2>
 80008f8:	b91b      	cbnz	r3, 8000902 <strcmp+0x1ba>
 80008fa:	4620      	mov	r0, r4
 80008fc:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000900:	4770      	bx	lr
 8000902:	f101 0104 	add.w	r1, r1, #4
 8000906:	f850 2b04 	ldr.w	r2, [r0], #4
 800090a:	07cc      	lsls	r4, r1, #31
 800090c:	f021 0103 	bic.w	r1, r1, #3
 8000910:	f851 3b04 	ldr.w	r3, [r1], #4
 8000914:	d848      	bhi.n	80009a8 <strcmp+0x260>
 8000916:	d224      	bcs.n	8000962 <strcmp+0x21a>
 8000918:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800091c:	fa82 f54c 	uadd8	r5, r2, ip
 8000920:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000924:	faa5 f58c 	sel	r5, r5, ip
 8000928:	d10a      	bne.n	8000940 <strcmp+0x1f8>
 800092a:	b965      	cbnz	r5, 8000946 <strcmp+0x1fe>
 800092c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000930:	ea84 0402 	eor.w	r4, r4, r2
 8000934:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000938:	d10e      	bne.n	8000958 <strcmp+0x210>
 800093a:	f850 2b04 	ldr.w	r2, [r0], #4
 800093e:	e7eb      	b.n	8000918 <strcmp+0x1d0>
 8000940:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000944:	e055      	b.n	80009f2 <strcmp+0x2aa>
 8000946:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 800094a:	d14d      	bne.n	80009e8 <strcmp+0x2a0>
 800094c:	7808      	ldrb	r0, [r1, #0]
 800094e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000952:	f1c0 0000 	rsb	r0, r0, #0
 8000956:	4770      	bx	lr
 8000958:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800095c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000960:	e047      	b.n	80009f2 <strcmp+0x2aa>
 8000962:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000966:	fa82 f54c 	uadd8	r5, r2, ip
 800096a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 800096e:	faa5 f58c 	sel	r5, r5, ip
 8000972:	d10a      	bne.n	800098a <strcmp+0x242>
 8000974:	b965      	cbnz	r5, 8000990 <strcmp+0x248>
 8000976:	f851 3b04 	ldr.w	r3, [r1], #4
 800097a:	ea84 0402 	eor.w	r4, r4, r2
 800097e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000982:	d10c      	bne.n	800099e <strcmp+0x256>
 8000984:	f850 2b04 	ldr.w	r2, [r0], #4
 8000988:	e7eb      	b.n	8000962 <strcmp+0x21a>
 800098a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800098e:	e030      	b.n	80009f2 <strcmp+0x2aa>
 8000990:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000994:	d128      	bne.n	80009e8 <strcmp+0x2a0>
 8000996:	880b      	ldrh	r3, [r1, #0]
 8000998:	ea4f 4212 	mov.w	r2, r2, lsr #16
 800099c:	e029      	b.n	80009f2 <strcmp+0x2aa>
 800099e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80009a2:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 80009a6:	e024      	b.n	80009f2 <strcmp+0x2aa>
 80009a8:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 80009ac:	fa82 f54c 	uadd8	r5, r2, ip
 80009b0:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 80009b4:	faa5 f58c 	sel	r5, r5, ip
 80009b8:	d10a      	bne.n	80009d0 <strcmp+0x288>
 80009ba:	b965      	cbnz	r5, 80009d6 <strcmp+0x28e>
 80009bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80009c0:	ea84 0402 	eor.w	r4, r4, r2
 80009c4:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 80009c8:	d109      	bne.n	80009de <strcmp+0x296>
 80009ca:	f850 2b04 	ldr.w	r2, [r0], #4
 80009ce:	e7eb      	b.n	80009a8 <strcmp+0x260>
 80009d0:	ea4f 6313 	mov.w	r3, r3, lsr #24
 80009d4:	e00d      	b.n	80009f2 <strcmp+0x2aa>
 80009d6:	f015 0fff 	tst.w	r5, #255	; 0xff
 80009da:	d105      	bne.n	80009e8 <strcmp+0x2a0>
 80009dc:	680b      	ldr	r3, [r1, #0]
 80009de:	ea4f 2212 	mov.w	r2, r2, lsr #8
 80009e2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80009e6:	e004      	b.n	80009f2 <strcmp+0x2aa>
 80009e8:	f04f 0000 	mov.w	r0, #0
 80009ec:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80009f0:	4770      	bx	lr
 80009f2:	ba12      	rev	r2, r2
 80009f4:	ba1b      	rev	r3, r3
 80009f6:	fa82 f44c 	uadd8	r4, r2, ip
 80009fa:	ea82 0403 	eor.w	r4, r2, r3
 80009fe:	faa4 f58c 	sel	r5, r4, ip
 8000a02:	fab5 f485 	clz	r4, r5
 8000a06:	fa02 f204 	lsl.w	r2, r2, r4
 8000a0a:	fa03 f304 	lsl.w	r3, r3, r4
 8000a0e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000a12:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000a16:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 8000a1a:	4770      	bx	lr
 8000a1c:	0000      	movs	r0, r0
	...

08000a20 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000a20:	4770      	bx	lr
 8000a22:	bf00      	nop
	...

08000a30 <__late_init>:
 8000a30:	4770      	bx	lr
 8000a32:	bf00      	nop
	...

08000a40 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8000a40:	e7fe      	b.n	8000a40 <__default_exit>
 8000a42:	bf00      	nop
	...

08000a50 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000a50:	b4f0      	push	{r4, r5, r6, r7}
 8000a52:	4e14      	ldr	r6, [pc, #80]	; (8000aa4 <__init_ram_areas+0x54>)
 8000a54:	4d14      	ldr	r5, [pc, #80]	; (8000aa8 <__init_ram_areas+0x58>)
 8000a56:	4c15      	ldr	r4, [pc, #84]	; (8000aac <__init_ram_areas+0x5c>)
 8000a58:	4b15      	ldr	r3, [pc, #84]	; (8000ab0 <__init_ram_areas+0x60>)
 8000a5a:	4916      	ldr	r1, [pc, #88]	; (8000ab4 <__init_ram_areas+0x64>)
 8000a5c:	f106 0c70 	add.w	ip, r6, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8000a60:	2700      	movs	r7, #0
    while (p < rap->clear_area) {
 8000a62:	429c      	cmp	r4, r3
 8000a64:	d911      	bls.n	8000a8a <__init_ram_areas+0x3a>
 8000a66:	3904      	subs	r1, #4
 8000a68:	461a      	mov	r2, r3
      *p = *tp;
 8000a6a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8000a6e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 8000a72:	4294      	cmp	r4, r2
 8000a74:	d8f9      	bhi.n	8000a6a <__init_ram_areas+0x1a>
 8000a76:	43da      	mvns	r2, r3
 8000a78:	4414      	add	r4, r2
 8000a7a:	f024 0403 	bic.w	r4, r4, #3
 8000a7e:	3404      	adds	r4, #4
 8000a80:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 8000a82:	429d      	cmp	r5, r3
 8000a84:	d903      	bls.n	8000a8e <__init_ram_areas+0x3e>
      *p = 0;
 8000a86:	f843 7b04 	str.w	r7, [r3], #4
    while (p < rap->no_init_area) {
 8000a8a:	429d      	cmp	r5, r3
 8000a8c:	d8fb      	bhi.n	8000a86 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000a8e:	4566      	cmp	r6, ip
 8000a90:	d005      	beq.n	8000a9e <__init_ram_areas+0x4e>
 8000a92:	e9d6 1304 	ldrd	r1, r3, [r6, #16]
 8000a96:	e9d6 4506 	ldrd	r4, r5, [r6, #24]
 8000a9a:	3610      	adds	r6, #16
 8000a9c:	e7e1      	b.n	8000a62 <__init_ram_areas+0x12>
#endif
}
 8000a9e:	bcf0      	pop	{r4, r5, r6, r7}
 8000aa0:	4770      	bx	lr
 8000aa2:	bf00      	nop
 8000aa4:	0800324c 	.word	0x0800324c
 8000aa8:	200012f0 	.word	0x200012f0
 8000aac:	200012f0 	.word	0x200012f0
 8000ab0:	200012f0 	.word	0x200012f0
 8000ab4:	080037ec 	.word	0x080037ec
	...

08000ac0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000ac0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8000ac2:	f000 faad 	bl	8001020 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 8000ac6:	f000 fb63 	bl	8001190 <_pal_lld_init>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 8000aca:	f000 f9b9 	bl	8000e40 <pwmInit>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000ace:	f000 fa0f 	bl	8000ef0 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000ad2:	f000 fe1d 	bl	8001710 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8000ad6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stInit();
 8000ada:	f000 b801 	b.w	8000ae0 <stInit>
 8000ade:	bf00      	nop

08000ae0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 8000ae0:	f000 bbe6 	b.w	80012b0 <st_lld_init>
	...

08000af0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000af0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 8000af4:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000af6:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000af8:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000afa:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000afc:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 8000afe:	4770      	bx	lr

08000b00 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000b00:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000b04:	2200      	movs	r2, #0
 8000b06:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8000b08:	4770      	bx	lr
 8000b0a:	bf00      	nop
 8000b0c:	0000      	movs	r0, r0
	...

08000b10 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000b10:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000b14:	6358      	str	r0, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 8000b16:	4770      	bx	lr
	...

08000b20 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000b20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000b22:	4615      	mov	r5, r2
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8000b24:	6882      	ldr	r2, [r0, #8]
    n = iqGetFullI(iqp);
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000b26:	6906      	ldr	r6, [r0, #16]
  if (n > iqGetFullI(iqp)) {
 8000b28:	42aa      	cmp	r2, r5
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000b2a:	460b      	mov	r3, r1
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000b2c:	6981      	ldr	r1, [r0, #24]
    n = iqGetFullI(iqp);
 8000b2e:	bf38      	it	cc
 8000b30:	6885      	ldrcc	r5, [r0, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000b32:	1a76      	subs	r6, r6, r1
  /*lint -restore*/
  if (n < s1) {
 8000b34:	42b5      	cmp	r5, r6
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000b36:	4604      	mov	r4, r0
  if (n < s1) {
 8000b38:	d31d      	bcc.n	8000b76 <iq_read+0x56>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
 8000b3a:	d80a      	bhi.n	8000b52 <iq_read+0x32>
    s2 = n - s1;
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
    iqp->q_rdptr = iqp->q_buffer + s2;
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000b3c:	4618      	mov	r0, r3
 8000b3e:	462a      	mov	r2, r5
 8000b40:	f7ff fd5a 	bl	80005f8 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8000b44:	68e3      	ldr	r3, [r4, #12]
 8000b46:	61a3      	str	r3, [r4, #24]
  }

  iqp->q_counter -= n;
 8000b48:	68a3      	ldr	r3, [r4, #8]
 8000b4a:	1b5b      	subs	r3, r3, r5
 8000b4c:	60a3      	str	r3, [r4, #8]
  return n;
}
 8000b4e:	4628      	mov	r0, r5
 8000b50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000b52:	4632      	mov	r2, r6
 8000b54:	4618      	mov	r0, r3
 8000b56:	f7ff fd4f 	bl	80005f8 <memcpy>
    s2 = n - s1;
 8000b5a:	1baf      	subs	r7, r5, r6
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000b5c:	463a      	mov	r2, r7
 8000b5e:	4430      	add	r0, r6
 8000b60:	68e1      	ldr	r1, [r4, #12]
 8000b62:	f7ff fd49 	bl	80005f8 <memcpy>
  iqp->q_counter -= n;
 8000b66:	68a3      	ldr	r3, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000b68:	68e2      	ldr	r2, [r4, #12]
  iqp->q_counter -= n;
 8000b6a:	1b5b      	subs	r3, r3, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000b6c:	443a      	add	r2, r7
 8000b6e:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 8000b70:	60a3      	str	r3, [r4, #8]
}
 8000b72:	4628      	mov	r0, r5
 8000b74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000b76:	4618      	mov	r0, r3
 8000b78:	462a      	mov	r2, r5
 8000b7a:	f7ff fd3d 	bl	80005f8 <memcpy>
    iqp->q_rdptr += n;
 8000b7e:	69a3      	ldr	r3, [r4, #24]
 8000b80:	442b      	add	r3, r5
 8000b82:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000b84:	68a3      	ldr	r3, [r4, #8]
 8000b86:	1b5b      	subs	r3, r3, r5
 8000b88:	60a3      	str	r3, [r4, #8]
}
 8000b8a:	4628      	mov	r0, r5
 8000b8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000b8e:	bf00      	nop

08000b90 <oq_write>:
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8000b90:	6883      	ldr	r3, [r0, #8]
 8000b92:	4293      	cmp	r3, r2
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    n = oqGetEmptyI(oqp);
 8000b98:	bf38      	it	cc
 8000b9a:	6885      	ldrcc	r5, [r0, #8]
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000b9c:	4604      	mov	r4, r0
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000b9e:	e9d0 6004 	ldrd	r6, r0, [r0, #16]
 8000ba2:	bf28      	it	cs
 8000ba4:	4615      	movcs	r5, r2
 8000ba6:	1a36      	subs	r6, r6, r0
  /*lint -restore*/
  if (n < s1) {
 8000ba8:	42b5      	cmp	r5, r6
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000baa:	460f      	mov	r7, r1
  if (n < s1) {
 8000bac:	d319      	bcc.n	8000be2 <oq_write+0x52>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
 8000bae:	d80a      	bhi.n	8000bc6 <oq_write+0x36>
    s2 = n - s1;
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
    oqp->q_wrptr = oqp->q_buffer + s2;
  }
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000bb0:	462a      	mov	r2, r5
 8000bb2:	f7ff fd21 	bl	80005f8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000bb6:	68e3      	ldr	r3, [r4, #12]
 8000bb8:	6163      	str	r3, [r4, #20]
  }

  oqp->q_counter -= n;
 8000bba:	68a3      	ldr	r3, [r4, #8]
 8000bbc:	1b5b      	subs	r3, r3, r5
 8000bbe:	60a3      	str	r3, [r4, #8]
  return n;
}
 8000bc0:	4628      	mov	r0, r5
 8000bc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000bc6:	4632      	mov	r2, r6
    s2 = n - s1;
 8000bc8:	eba5 0806 	sub.w	r8, r5, r6
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000bcc:	f7ff fd14 	bl	80005f8 <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000bd0:	4642      	mov	r2, r8
 8000bd2:	19b9      	adds	r1, r7, r6
 8000bd4:	68e0      	ldr	r0, [r4, #12]
 8000bd6:	f7ff fd0f 	bl	80005f8 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000bda:	68e2      	ldr	r2, [r4, #12]
 8000bdc:	4442      	add	r2, r8
 8000bde:	6162      	str	r2, [r4, #20]
 8000be0:	e7eb      	b.n	8000bba <oq_write+0x2a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000be2:	462a      	mov	r2, r5
 8000be4:	f7ff fd08 	bl	80005f8 <memcpy>
    oqp->q_wrptr += n;
 8000be8:	6963      	ldr	r3, [r4, #20]
 8000bea:	442b      	add	r3, r5
 8000bec:	6163      	str	r3, [r4, #20]
 8000bee:	e7e4      	b.n	8000bba <oq_write+0x2a>

08000bf0 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
 8000bf0:	b430      	push	{r4, r5}
 8000bf2:	9c02      	ldr	r4, [sp, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8000bf4:	6204      	str	r4, [r0, #32]
  iqp->q_counter = 0;
 8000bf6:	2500      	movs	r5, #0
  iqp->q_top     = bp + size;
 8000bf8:	440a      	add	r2, r1
  iqp->q_counter = 0;
 8000bfa:	6085      	str	r5, [r0, #8]
  iqp->q_top     = bp + size;
 8000bfc:	6102      	str	r2, [r0, #16]
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
  tqp->prev = (thread_t *)tqp;
 8000bfe:	e9c0 0000 	strd	r0, r0, [r0]
  iqp->q_buffer  = bp;
 8000c02:	60c1      	str	r1, [r0, #12]
  iqp->q_wrptr   = bp;
 8000c04:	e9c0 1105 	strd	r1, r1, [r0, #20]
  iqp->q_notify  = infy;
 8000c08:	61c3      	str	r3, [r0, #28]
}
 8000c0a:	bc30      	pop	{r4, r5}
 8000c0c:	4770      	bx	lr
 8000c0e:	bf00      	nop

08000c10 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8000c10:	e9d0 3205 	ldrd	r3, r2, [r0, #20]
 8000c14:	4293      	cmp	r3, r2
 8000c16:	d011      	beq.n	8000c3c <iqPutI+0x2c>
    iqp->q_counter++;
 8000c18:	6882      	ldr	r2, [r0, #8]
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8000c1a:	b510      	push	{r4, lr}
    iqp->q_counter++;
 8000c1c:	3201      	adds	r2, #1
    *iqp->q_wrptr++ = b;
 8000c1e:	1c5c      	adds	r4, r3, #1
    iqp->q_counter++;
 8000c20:	6082      	str	r2, [r0, #8]
    *iqp->q_wrptr++ = b;
 8000c22:	6144      	str	r4, [r0, #20]
 8000c24:	7019      	strb	r1, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000c26:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 8000c2a:	429a      	cmp	r2, r3
 8000c2c:	d301      	bcc.n	8000c32 <iqPutI+0x22>
      iqp->q_wrptr = iqp->q_buffer;
 8000c2e:	68c3      	ldr	r3, [r0, #12]
 8000c30:	6143      	str	r3, [r0, #20]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8000c32:	2100      	movs	r1, #0
 8000c34:	f001 f8f4 	bl	8001e20 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

    return MSG_OK;
 8000c38:	2000      	movs	r0, #0
  }

  return MSG_TIMEOUT;
}
 8000c3a:	bd10      	pop	{r4, pc}
  if (!iqIsFullI(iqp)) {
 8000c3c:	6882      	ldr	r2, [r0, #8]
 8000c3e:	2a00      	cmp	r2, #0
 8000c40:	d0ea      	beq.n	8000c18 <iqPutI+0x8>
  return MSG_TIMEOUT;
 8000c42:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8000c46:	4770      	bx	lr
	...

08000c50 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000c50:	b570      	push	{r4, r5, r6, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000c52:	2320      	movs	r3, #32
 8000c54:	4604      	mov	r4, r0
 8000c56:	460e      	mov	r6, r1
 8000c58:	f383 8811 	msr	BASEPRI, r3
 8000c5c:	e003      	b.n	8000c66 <iqGetTimeout+0x16>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000c5e:	f001 f8c7 	bl	8001df0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000c62:	2800      	cmp	r0, #0
 8000c64:	db1a      	blt.n	8000c9c <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 8000c66:	68a5      	ldr	r5, [r4, #8]
 8000c68:	4631      	mov	r1, r6
 8000c6a:	4620      	mov	r0, r4
 8000c6c:	2d00      	cmp	r5, #0
 8000c6e:	d0f6      	beq.n	8000c5e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000c70:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
 8000c72:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000c74:	6920      	ldr	r0, [r4, #16]
  b = *iqp->q_rdptr++;
 8000c76:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000c78:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000c7a:	4282      	cmp	r2, r0
  iqp->q_counter--;
 8000c7c:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000c7e:	61a2      	str	r2, [r4, #24]
    iqp->q_rdptr = iqp->q_buffer;
 8000c80:	bf28      	it	cs
 8000c82:	68e3      	ldrcs	r3, [r4, #12]
  b = *iqp->q_rdptr++;
 8000c84:	780d      	ldrb	r5, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000c86:	bf28      	it	cs
 8000c88:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8000c8a:	69e3      	ldr	r3, [r4, #28]
 8000c8c:	b10b      	cbz	r3, 8000c92 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8000c8e:	4620      	mov	r0, r4
 8000c90:	4798      	blx	r3
 8000c92:	2300      	movs	r3, #0
 8000c94:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 8000c98:	4628      	mov	r0, r5
}
 8000c9a:	bd70      	pop	{r4, r5, r6, pc}
 8000c9c:	f385 8811 	msr	BASEPRI, r5
 8000ca0:	bd70      	pop	{r4, r5, r6, pc}
 8000ca2:	bf00      	nop
	...

08000cb0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8000cb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000cb4:	b083      	sub	sp, #12
 8000cb6:	4617      	mov	r7, r2
 8000cb8:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = iqp->q_notify;
 8000cba:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000cbe:	f04f 0920 	mov.w	r9, #32
 8000cc2:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (rd < n) {
 8000cc6:	b332      	cbz	r2, 8000d16 <iqReadTimeout+0x66>
  size_t rd = 0;
 8000cc8:	2400      	movs	r4, #0
 8000cca:	4606      	mov	r6, r0
 8000ccc:	460d      	mov	r5, r1
 8000cce:	46a2      	mov	sl, r4
 8000cd0:	e00c      	b.n	8000cec <iqReadTimeout+0x3c>
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
        nfy(iqp);
 8000cd2:	4630      	mov	r0, r6
      if (nfy != NULL) {
 8000cd4:	f1b8 0f00 	cmp.w	r8, #0
 8000cd8:	d000      	beq.n	8000cdc <iqReadTimeout+0x2c>
        nfy(iqp);
 8000cda:	47c0      	blx	r8
 8000cdc:	f38a 8811 	msr	BASEPRI, sl
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      rd += done;
 8000ce0:	445c      	add	r4, fp
      bp += done;
 8000ce2:	445d      	add	r5, fp
 8000ce4:	f389 8811 	msr	BASEPRI, r9
  while (rd < n) {
 8000ce8:	42a7      	cmp	r7, r4
 8000cea:	d90d      	bls.n	8000d08 <iqReadTimeout+0x58>
    done = iq_read(iqp, bp, n);
 8000cec:	463a      	mov	r2, r7
 8000cee:	4629      	mov	r1, r5
 8000cf0:	4630      	mov	r0, r6
 8000cf2:	f7ff ff15 	bl	8000b20 <iq_read>
    if (done == (size_t)0) {
 8000cf6:	4683      	mov	fp, r0
 8000cf8:	2800      	cmp	r0, #0
 8000cfa:	d1ea      	bne.n	8000cd2 <iqReadTimeout+0x22>
 8000cfc:	9901      	ldr	r1, [sp, #4]
 8000cfe:	4630      	mov	r0, r6
 8000d00:	f001 f876 	bl	8001df0 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000d04:	2800      	cmp	r0, #0
 8000d06:	d0ef      	beq.n	8000ce8 <iqReadTimeout+0x38>
 8000d08:	2300      	movs	r3, #0
 8000d0a:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return rd;
}
 8000d0e:	4620      	mov	r0, r4
 8000d10:	b003      	add	sp, #12
 8000d12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  size_t rd = 0;
 8000d16:	4614      	mov	r4, r2
 8000d18:	e7f6      	b.n	8000d08 <iqReadTimeout+0x58>
 8000d1a:	bf00      	nop
 8000d1c:	0000      	movs	r0, r0
	...

08000d20 <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
 8000d20:	b430      	push	{r4, r5}
 8000d22:	9c02      	ldr	r4, [sp, #8]

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000d24:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000d26:	188d      	adds	r5, r1, r2
  oqp->q_buffer  = bp;
 8000d28:	e9c0 1503 	strd	r1, r5, [r0, #12]
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000d2c:	e9c0 3407 	strd	r3, r4, [r0, #28]
 8000d30:	e9c0 0000 	strd	r0, r0, [r0]
  oqp->q_wrptr   = bp;
 8000d34:	e9c0 1105 	strd	r1, r1, [r0, #20]
}
 8000d38:	bc30      	pop	{r4, r5}
 8000d3a:	4770      	bx	lr
 8000d3c:	0000      	movs	r0, r0
	...

08000d40 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000d42:	4604      	mov	r4, r0
 8000d44:	460f      	mov	r7, r1
 8000d46:	4616      	mov	r6, r2
 8000d48:	2320      	movs	r3, #32
 8000d4a:	f383 8811 	msr	BASEPRI, r3
 8000d4e:	e003      	b.n	8000d58 <oqPutTimeout+0x18>
 8000d50:	f001 f84e 	bl	8001df0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000d54:	2800      	cmp	r0, #0
 8000d56:	db18      	blt.n	8000d8a <oqPutTimeout+0x4a>
  while (oqIsFullI(oqp)) {
 8000d58:	68a5      	ldr	r5, [r4, #8]
 8000d5a:	4631      	mov	r1, r6
 8000d5c:	4620      	mov	r0, r4
 8000d5e:	2d00      	cmp	r5, #0
 8000d60:	d0f6      	beq.n	8000d50 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000d62:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000d64:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d66:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000d68:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000d6a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000d6c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d6e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000d70:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000d74:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000d76:	bf24      	itt	cs
 8000d78:	68e3      	ldrcs	r3, [r4, #12]
 8000d7a:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000d7c:	69e3      	ldr	r3, [r4, #28]
 8000d7e:	b103      	cbz	r3, 8000d82 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 8000d80:	4798      	blx	r3
 8000d82:	2000      	movs	r0, #0
 8000d84:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000d88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000d8a:	f385 8811 	msr	BASEPRI, r5
 8000d8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000d90 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8000d90:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8000d92:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 8000d96:	429a      	cmp	r2, r3
 8000d98:	d00f      	beq.n	8000dba <oqGetI+0x2a>
    uint8_t b;

    oqp->q_counter++;
 8000d9a:	6882      	ldr	r2, [r0, #8]
    b = *oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top) {
 8000d9c:	6905      	ldr	r5, [r0, #16]
    b = *oqp->q_rdptr++;
 8000d9e:	1c59      	adds	r1, r3, #1
    oqp->q_counter++;
 8000da0:	3201      	adds	r2, #1
 8000da2:	6082      	str	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 8000da4:	6181      	str	r1, [r0, #24]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000da6:	42a9      	cmp	r1, r5
    b = *oqp->q_rdptr++;
 8000da8:	781c      	ldrb	r4, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000daa:	d301      	bcc.n	8000db0 <oqGetI+0x20>
      oqp->q_rdptr = oqp->q_buffer;
 8000dac:	68c3      	ldr	r3, [r0, #12]
 8000dae:	6183      	str	r3, [r0, #24]
  chThdDequeueNextI(tqp, msg);
 8000db0:	2100      	movs	r1, #0
 8000db2:	f001 f835 	bl	8001e20 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
 8000db6:	4620      	mov	r0, r4
  }

  return MSG_TIMEOUT;
}
 8000db8:	bd38      	pop	{r3, r4, r5, pc}
  if (!oqIsEmptyI(oqp)) {
 8000dba:	6882      	ldr	r2, [r0, #8]
 8000dbc:	2a00      	cmp	r2, #0
 8000dbe:	d0ec      	beq.n	8000d9a <oqGetI+0xa>
  return MSG_TIMEOUT;
 8000dc0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8000dc4:	bd38      	pop	{r3, r4, r5, pc}
 8000dc6:	bf00      	nop
	...

08000dd0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000dd4:	b083      	sub	sp, #12
 8000dd6:	4617      	mov	r7, r2
 8000dd8:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8000dda:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000dde:	f04f 0920 	mov.w	r9, #32
 8000de2:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (wr < n) {
 8000de6:	b332      	cbz	r2, 8000e36 <oqWriteTimeout+0x66>
  size_t wr = 0;
 8000de8:	2400      	movs	r4, #0
 8000dea:	4606      	mov	r6, r0
 8000dec:	460d      	mov	r5, r1
 8000dee:	46a2      	mov	sl, r4
 8000df0:	e00c      	b.n	8000e0c <oqWriteTimeout+0x3c>
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
        nfy(oqp);
 8000df2:	4630      	mov	r0, r6
      if (nfy != NULL) {
 8000df4:	f1b8 0f00 	cmp.w	r8, #0
 8000df8:	d000      	beq.n	8000dfc <oqWriteTimeout+0x2c>
        nfy(oqp);
 8000dfa:	47c0      	blx	r8
 8000dfc:	f38a 8811 	msr	BASEPRI, sl
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      wr += done;
 8000e00:	445c      	add	r4, fp
      bp += done;
 8000e02:	445d      	add	r5, fp
 8000e04:	f389 8811 	msr	BASEPRI, r9
  while (wr < n) {
 8000e08:	42a7      	cmp	r7, r4
 8000e0a:	d90d      	bls.n	8000e28 <oqWriteTimeout+0x58>
    done = oq_write(oqp, bp, n);
 8000e0c:	463a      	mov	r2, r7
 8000e0e:	4629      	mov	r1, r5
 8000e10:	4630      	mov	r0, r6
 8000e12:	f7ff febd 	bl	8000b90 <oq_write>
    if (done == (size_t)0) {
 8000e16:	4683      	mov	fp, r0
 8000e18:	2800      	cmp	r0, #0
 8000e1a:	d1ea      	bne.n	8000df2 <oqWriteTimeout+0x22>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000e1c:	9901      	ldr	r1, [sp, #4]
 8000e1e:	4630      	mov	r0, r6
 8000e20:	f000 ffe6 	bl	8001df0 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 8000e24:	2800      	cmp	r0, #0
 8000e26:	d0ef      	beq.n	8000e08 <oqWriteTimeout+0x38>
 8000e28:	2300      	movs	r3, #0
 8000e2a:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return wr;
}
 8000e2e:	4620      	mov	r0, r4
 8000e30:	b003      	add	sp, #12
 8000e32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  size_t wr = 0;
 8000e36:	4614      	mov	r4, r2
 8000e38:	e7f6      	b.n	8000e28 <oqWriteTimeout+0x58>
 8000e3a:	bf00      	nop
 8000e3c:	0000      	movs	r0, r0
	...

08000e40 <pwmInit>:
 *
 * @init
 */
void pwmInit(void) {

  pwm_lld_init();
 8000e40:	f000 ba5e 	b.w	8001300 <pwm_lld_init>
	...

08000e50 <pwmObjectInit>:
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 8000e50:	2300      	movs	r3, #0
  pwmp->state    = PWM_STOP;
 8000e52:	2201      	movs	r2, #1
 8000e54:	7002      	strb	r2, [r0, #0]
  pwmp->config   = NULL;
 8000e56:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8000e58:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 8000e5a:	7403      	strb	r3, [r0, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 8000e5c:	4770      	bx	lr
 8000e5e:	bf00      	nop

08000e60 <_readt>:
}

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000e60:	300c      	adds	r0, #12
 8000e62:	f7ff bf25 	b.w	8000cb0 <iqReadTimeout>
 8000e66:	bf00      	nop
	...

08000e70 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000e70:	300c      	adds	r0, #12
 8000e72:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000e76:	f7ff bf1b 	b.w	8000cb0 <iqReadTimeout>
 8000e7a:	bf00      	nop
 8000e7c:	0000      	movs	r0, r0
	...

08000e80 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000e80:	3030      	adds	r0, #48	; 0x30
 8000e82:	f7ff bfa5 	b.w	8000dd0 <oqWriteTimeout>
 8000e86:	bf00      	nop
	...

08000e90 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000e90:	3030      	adds	r0, #48	; 0x30
 8000e92:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000e96:	f7ff bf9b 	b.w	8000dd0 <oqWriteTimeout>
 8000e9a:	bf00      	nop
 8000e9c:	0000      	movs	r0, r0
	...

08000ea0 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000ea0:	300c      	adds	r0, #12
 8000ea2:	f7ff bed5 	b.w	8000c50 <iqGetTimeout>
 8000ea6:	bf00      	nop
	...

08000eb0 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000eb0:	300c      	adds	r0, #12
 8000eb2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000eb6:	f7ff becb 	b.w	8000c50 <iqGetTimeout>
 8000eba:	bf00      	nop
 8000ebc:	0000      	movs	r0, r0
	...

08000ec0 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000ec0:	3030      	adds	r0, #48	; 0x30
 8000ec2:	f7ff bf3d 	b.w	8000d40 <oqPutTimeout>
 8000ec6:	bf00      	nop
	...

08000ed0 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000ed0:	3030      	adds	r0, #48	; 0x30
 8000ed2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000ed6:	f7ff bf33 	b.w	8000d40 <oqPutTimeout>
 8000eda:	bf00      	nop
 8000edc:	0000      	movs	r0, r0
	...

08000ee0 <_ctl>:
 8000ee0:	2000      	movs	r0, #0
 8000ee2:	4770      	bx	lr
	...

08000ef0 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8000ef0:	f000 baf6 	b.w	80014e0 <sd_lld_init>
	...

08000f00 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000f00:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 8000f02:	4b0e      	ldr	r3, [pc, #56]	; (8000f3c <sdObjectInit+0x3c>)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000f04:	4604      	mov	r4, r0
 8000f06:	b082      	sub	sp, #8
  sdp->vmt = &vmt;
 8000f08:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000f0c:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000f0e:	9400      	str	r4, [sp, #0]
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000f10:	4615      	mov	r5, r2
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000f12:	460b      	mov	r3, r1
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000f14:	6060      	str	r0, [r4, #4]
 8000f16:	f104 0154 	add.w	r1, r4, #84	; 0x54
 8000f1a:	f104 000c 	add.w	r0, r4, #12
  sdp->state = SD_STOP;
 8000f1e:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000f20:	2210      	movs	r2, #16
 8000f22:	f7ff fe65 	bl	8000bf0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8000f26:	9400      	str	r4, [sp, #0]
 8000f28:	462b      	mov	r3, r5
 8000f2a:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8000f2e:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8000f32:	2210      	movs	r2, #16
 8000f34:	f7ff fef4 	bl	8000d20 <oqObjectInit>
}
 8000f38:	b002      	add	sp, #8
 8000f3a:	bd70      	pop	{r4, r5, r6, pc}
 8000f3c:	080032cc 	.word	0x080032cc

08000f40 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8000f40:	b510      	push	{r4, lr}
 8000f42:	2320      	movs	r3, #32
 8000f44:	4604      	mov	r4, r0
 8000f46:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 8000f4a:	f000 fad9 	bl	8001500 <sd_lld_start>
  sdp->state = SD_READY;
 8000f4e:	2302      	movs	r3, #2
 8000f50:	7223      	strb	r3, [r4, #8]
 8000f52:	2300      	movs	r3, #0
 8000f54:	f383 8811 	msr	BASEPRI, r3
  osalSysUnlock();
}
 8000f58:	bd10      	pop	{r4, pc}
 8000f5a:	bf00      	nop
 8000f5c:	0000      	movs	r0, r0
	...

08000f60 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000f60:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000f62:	6943      	ldr	r3, [r0, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000f64:	4604      	mov	r4, r0
 8000f66:	460d      	mov	r5, r1
  if (iqIsEmptyI(&sdp->iqueue))
 8000f68:	b13b      	cbz	r3, 8000f7a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8000f6a:	4629      	mov	r1, r5
 8000f6c:	f104 000c 	add.w	r0, r4, #12
 8000f70:	f7ff fe4e 	bl	8000c10 <iqPutI>
 8000f74:	2800      	cmp	r0, #0
 8000f76:	db0b      	blt.n	8000f90 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
 8000f78:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000f7a:	2104      	movs	r1, #4
 8000f7c:	4408      	add	r0, r1
 8000f7e:	f001 f8b7 	bl	80020f0 <chEvtBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8000f82:	4629      	mov	r1, r5
 8000f84:	f104 000c 	add.w	r0, r4, #12
 8000f88:	f7ff fe42 	bl	8000c10 <iqPutI>
 8000f8c:	2800      	cmp	r0, #0
 8000f8e:	daf3      	bge.n	8000f78 <sdIncomingDataI+0x18>
 8000f90:	1d20      	adds	r0, r4, #4
 8000f92:	f44f 6180 	mov.w	r1, #1024	; 0x400
}
 8000f96:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000f9a:	f001 b8a9 	b.w	80020f0 <chEvtBroadcastFlagsI>
 8000f9e:	bf00      	nop

08000fa0 <nvicEnableVector>:
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000fa0:	0943      	lsrs	r3, r0, #5
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000fa2:	b410      	push	{r4}
 8000fa4:	009b      	lsls	r3, r3, #2
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000fa6:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 8000faa:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8000fae:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8000fb2:	0109      	lsls	r1, r1, #4
 8000fb4:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000fb8:	f000 001f 	and.w	r0, r0, #31
 8000fbc:	2201      	movs	r2, #1
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000fbe:	b2c9      	uxtb	r1, r1
 8000fc0:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000fc4:	fa02 f000 	lsl.w	r0, r2, r0
 8000fc8:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
}
 8000fcc:	bc10      	pop	{r4}
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000fce:	6018      	str	r0, [r3, #0]
}
 8000fd0:	4770      	bx	lr
 8000fd2:	bf00      	nop
	...

08000fe0 <irqInit>:
 * @notapi
 */
void irqInit(void) {

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 8000fe0:	2106      	movs	r1, #6
void irqInit(void) {
 8000fe2:	b508      	push	{r3, lr}
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 8000fe4:	4608      	mov	r0, r1
 8000fe6:	f7ff ffdb 	bl	8000fa0 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 8000fea:	2106      	movs	r1, #6
 8000fec:	2007      	movs	r0, #7
 8000fee:	f7ff ffd7 	bl	8000fa0 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 8000ff2:	2106      	movs	r1, #6
 8000ff4:	2008      	movs	r0, #8
 8000ff6:	f7ff ffd3 	bl	8000fa0 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 8000ffa:	2106      	movs	r1, #6
 8000ffc:	2009      	movs	r0, #9
 8000ffe:	f7ff ffcf 	bl	8000fa0 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 8001002:	2106      	movs	r1, #6
 8001004:	200a      	movs	r0, #10
 8001006:	f7ff ffcb 	bl	8000fa0 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 800100a:	2106      	movs	r1, #6
 800100c:	2017      	movs	r0, #23
 800100e:	f7ff ffc7 	bl	8000fa0 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 8001012:	2106      	movs	r1, #6
 8001014:	2028      	movs	r0, #40	; 0x28
#endif
}
 8001016:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 800101a:	f7ff bfc1 	b.w	8000fa0 <nvicEnableVector>
 800101e:	bf00      	nop

08001020 <hal_lld_init>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001020:	4b1a      	ldr	r3, [pc, #104]	; (800108c <hal_lld_init+0x6c>)
  PWR->CR |= PWR_CR_DBP;
 8001022:	481b      	ldr	r0, [pc, #108]	; (8001090 <hal_lld_init+0x70>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001024:	691a      	ldr	r2, [r3, #16]
 8001026:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 800102a:	2100      	movs	r1, #0
 800102c:	ea6f 52d2 	mvn.w	r2, r2, lsr #23
void hal_lld_init(void) {
 8001030:	b410      	push	{r4}
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001032:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8001034:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001038:	6119      	str	r1, [r3, #16]
  rccResetAHB2(~0);
 800103a:	695a      	ldr	r2, [r3, #20]
 800103c:	615c      	str	r4, [r3, #20]
 800103e:	6159      	str	r1, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001040:	6a1a      	ldr	r2, [r3, #32]
 8001042:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 8001046:	621a      	str	r2, [r3, #32]
 8001048:	6219      	str	r1, [r3, #32]
  rccResetAPB2(~0);
 800104a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800104c:	625c      	str	r4, [r3, #36]	; 0x24
 800104e:	6259      	str	r1, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8001050:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001052:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001056:	641a      	str	r2, [r3, #64]	; 0x40
 8001058:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800105a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800105e:	661a      	str	r2, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 8001060:	6802      	ldr	r2, [r0, #0]
 8001062:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001066:	6002      	str	r2, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001068:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800106a:	f402 7240 	and.w	r2, r2, #768	; 0x300
 800106e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8001072:	d003      	beq.n	800107c <hal_lld_init+0x5c>
    RCC->BDCR = RCC_BDCR_BDRST;
 8001074:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001078:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800107a:	6719      	str	r1, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 800107c:	4a04      	ldr	r2, [pc, #16]	; (8001090 <hal_lld_init+0x70>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 800107e:	bc10      	pop	{r4}
  PWR->CSR &= ~PWR_CSR_BRE;
 8001080:	6853      	ldr	r3, [r2, #4]
 8001082:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001086:	6053      	str	r3, [r2, #4]
  irqInit();
 8001088:	f7ff bfaa 	b.w	8000fe0 <irqInit>
 800108c:	40023800 	.word	0x40023800
 8001090:	40007000 	.word	0x40007000
	...

080010a0 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80010a0:	4b31      	ldr	r3, [pc, #196]	; (8001168 <stm32_clock_init+0xc8>)
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80010a2:	4a32      	ldr	r2, [pc, #200]	; (800116c <stm32_clock_init+0xcc>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80010a4:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  PWR->CR = STM32_VOS;
 80010a8:	f44f 4140 	mov.w	r1, #49152	; 0xc000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80010ac:	6418      	str	r0, [r3, #64]	; 0x40
  PWR->CR = STM32_VOS;
 80010ae:	6011      	str	r1, [r2, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80010b0:	681a      	ldr	r2, [r3, #0]
 80010b2:	f042 0201 	orr.w	r2, r2, #1
 80010b6:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80010b8:	681a      	ldr	r2, [r3, #0]
 80010ba:	0792      	lsls	r2, r2, #30
 80010bc:	d5fc      	bpl.n	80010b8 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 80010be:	6899      	ldr	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010c0:	4a29      	ldr	r2, [pc, #164]	; (8001168 <stm32_clock_init+0xc8>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 80010c2:	f021 0103 	bic.w	r1, r1, #3
 80010c6:	6099      	str	r1, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80010c8:	6893      	ldr	r3, [r2, #8]
 80010ca:	f013 030c 	ands.w	r3, r3, #12
 80010ce:	d1fb      	bne.n	80010c8 <stm32_clock_init+0x28>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010d0:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 80010d2:	4925      	ldr	r1, [pc, #148]	; (8001168 <stm32_clock_init+0xc8>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80010d4:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 80010d8:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80010da:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON;
 80010dc:	6813      	ldr	r3, [r2, #0]
 80010de:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80010e2:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 80010e4:	680b      	ldr	r3, [r1, #0]
 80010e6:	0398      	lsls	r0, r3, #14
 80010e8:	d5fc      	bpl.n	80010e4 <stm32_clock_init+0x44>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80010ea:	6f4b      	ldr	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80010ec:	4a1e      	ldr	r2, [pc, #120]	; (8001168 <stm32_clock_init+0xc8>)
  RCC->CSR |= RCC_CSR_LSION;
 80010ee:	f043 0301 	orr.w	r3, r3, #1
 80010f2:	674b      	str	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80010f4:	6f53      	ldr	r3, [r2, #116]	; 0x74
 80010f6:	0799      	lsls	r1, r3, #30
 80010f8:	d5fc      	bpl.n	80010f4 <stm32_clock_init+0x54>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80010fa:	4b1d      	ldr	r3, [pc, #116]	; (8001170 <stm32_clock_init+0xd0>)
 80010fc:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80010fe:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001100:	491a      	ldr	r1, [pc, #104]	; (800116c <stm32_clock_init+0xcc>)
  RCC->CR |= RCC_CR_PLLON;
 8001102:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001106:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001108:	684b      	ldr	r3, [r1, #4]
 800110a:	045a      	lsls	r2, r3, #17
 800110c:	d5fc      	bpl.n	8001108 <stm32_clock_init+0x68>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800110e:	4a16      	ldr	r2, [pc, #88]	; (8001168 <stm32_clock_init+0xc8>)
 8001110:	6813      	ldr	r3, [r2, #0]
 8001112:	019b      	lsls	r3, r3, #6
 8001114:	d5fc      	bpl.n	8001110 <stm32_clock_init+0x70>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8001116:	4b17      	ldr	r3, [pc, #92]	; (8001174 <stm32_clock_init+0xd4>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8001118:	4917      	ldr	r1, [pc, #92]	; (8001178 <stm32_clock_init+0xd8>)
 800111a:	6091      	str	r1, [r2, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800111c:	681a      	ldr	r2, [r3, #0]
 800111e:	4b17      	ldr	r3, [pc, #92]	; (800117c <stm32_clock_init+0xdc>)
 8001120:	429a      	cmp	r2, r3
 8001122:	d016      	beq.n	8001152 <stm32_clock_init+0xb2>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8001124:	4b16      	ldr	r3, [pc, #88]	; (8001180 <stm32_clock_init+0xe0>)
 8001126:	f240 7205 	movw	r2, #1797	; 0x705
 800112a:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800112c:	4a0e      	ldr	r2, [pc, #56]	; (8001168 <stm32_clock_init+0xc8>)
 800112e:	6893      	ldr	r3, [r2, #8]
 8001130:	f043 0302 	orr.w	r3, r3, #2
 8001134:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001136:	6893      	ldr	r3, [r2, #8]
 8001138:	f003 030c 	and.w	r3, r3, #12
 800113c:	2b08      	cmp	r3, #8
 800113e:	d1fa      	bne.n	8001136 <stm32_clock_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8001140:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8001142:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001146:	6453      	str	r3, [r2, #68]	; 0x44
 8001148:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800114a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800114e:	6653      	str	r3, [r2, #100]	; 0x64
}
 8001150:	4770      	bx	lr
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8001152:	4a0c      	ldr	r2, [pc, #48]	; (8001184 <stm32_clock_init+0xe4>)
 8001154:	4b0c      	ldr	r3, [pc, #48]	; (8001188 <stm32_clock_init+0xe8>)
 8001156:	6812      	ldr	r2, [r2, #0]
 8001158:	429a      	cmp	r2, r3
 800115a:	d1e3      	bne.n	8001124 <stm32_clock_init+0x84>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 800115c:	4b08      	ldr	r3, [pc, #32]	; (8001180 <stm32_clock_init+0xe0>)
 800115e:	f240 1205 	movw	r2, #261	; 0x105
 8001162:	601a      	str	r2, [r3, #0]
 8001164:	e7e2      	b.n	800112c <stm32_clock_init+0x8c>
 8001166:	bf00      	nop
 8001168:	40023800 	.word	0x40023800
 800116c:	40007000 	.word	0x40007000
 8001170:	07405408 	.word	0x07405408
 8001174:	e0042000 	.word	0xe0042000
 8001178:	38889400 	.word	0x38889400
 800117c:	20006411 	.word	0x20006411
 8001180:	40023c00 	.word	0x40023c00
 8001184:	e000ed00 	.word	0xe000ed00
 8001188:	410fc241 	.word	0x410fc241
 800118c:	00000000 	.word	0x00000000

08001190 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001190:	4770      	bx	lr
 8001192:	bf00      	nop
	...

080011a0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80011a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80011a4:	f002 0903 	and.w	r9, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80011a8:	f3c2 0e80 	ubfx	lr, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80011ac:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80011b0:	f3c2 1741 	ubfx	r7, r2, #5, #2
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80011b4:	46c8      	mov	r8, r9
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80011b6:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t bit     = 0;
 80011ba:	2600      	movs	r6, #0
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 80011bc:	f04f 0a01 	mov.w	sl, #1
 80011c0:	e016      	b.n	80011f0 <_pal_lld_setgroupmode+0x50>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80011c2:	f8d0 b000 	ldr.w	fp, [r0]
 80011c6:	ea03 030b 	and.w	r3, r3, fp
 80011ca:	ea43 0308 	orr.w	r3, r3, r8
        if (bit < 8)
 80011ce:	2e07      	cmp	r6, #7
        port->MODER   = (port->MODER & ~m2) | moder;
 80011d0:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 80011d2:	d844      	bhi.n	800125e <_pal_lld_setgroupmode+0xbe>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80011d4:	6a03      	ldr	r3, [r0, #32]
 80011d6:	401d      	ands	r5, r3
 80011d8:	432c      	orrs	r4, r5
 80011da:	6204      	str	r4, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 80011dc:	0849      	lsrs	r1, r1, #1
 80011de:	d03c      	beq.n	800125a <_pal_lld_setgroupmode+0xba>
      return;
    otyper <<= 1;
 80011e0:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    ospeedr <<= 2;
 80011e4:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
 80011e8:	00bf      	lsls	r7, r7, #2
    moder <<= 2;
 80011ea:	ea4f 0888 	mov.w	r8, r8, lsl #2
    bit++;
 80011ee:	3601      	adds	r6, #1
    if ((mask & 1) != 0) {
 80011f0:	07cb      	lsls	r3, r1, #31
 80011f2:	d5f3      	bpl.n	80011dc <_pal_lld_setgroupmode+0x3c>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80011f4:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
 80011f6:	fa0a f406 	lsl.w	r4, sl, r6
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80011fa:	ea23 0304 	bic.w	r3, r3, r4
 80011fe:	ea43 030e 	orr.w	r3, r3, lr
 8001202:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
 8001204:	2503      	movs	r5, #3
 8001206:	0073      	lsls	r3, r6, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001208:	6884      	ldr	r4, [r0, #8]
      m2 = 3 << (bit * 2);
 800120a:	fa05 f303 	lsl.w	r3, r5, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800120e:	43db      	mvns	r3, r3
 8001210:	401c      	ands	r4, r3
 8001212:	ea44 040c 	orr.w	r4, r4, ip
 8001216:	6084      	str	r4, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001218:	68c5      	ldr	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 800121a:	f006 0407 	and.w	r4, r6, #7
 800121e:	00a4      	lsls	r4, r4, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001220:	401d      	ands	r5, r3
      m4 = 15 << ((bit & 7) * 4);
 8001222:	f04f 0b0f 	mov.w	fp, #15
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001226:	433d      	orrs	r5, r7
      m4 = 15 << ((bit & 7) * 4);
 8001228:	fa0b fb04 	lsl.w	fp, fp, r4
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800122c:	f1b9 0f02 	cmp.w	r9, #2
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001230:	60c5      	str	r5, [r0, #12]
      altrmask = altr << ((bit & 7) * 4);
 8001232:	fa02 f404 	lsl.w	r4, r2, r4
 8001236:	ea6f 050b 	mvn.w	r5, fp
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800123a:	d1c2      	bne.n	80011c2 <_pal_lld_setgroupmode+0x22>
        if (bit < 8)
 800123c:	2e07      	cmp	r6, #7
 800123e:	d813      	bhi.n	8001268 <_pal_lld_setgroupmode+0xc8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001240:	f8d0 b020 	ldr.w	fp, [r0, #32]
 8001244:	ea0b 0505 	and.w	r5, fp, r5
 8001248:	432c      	orrs	r4, r5
 800124a:	6204      	str	r4, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
 800124c:	6804      	ldr	r4, [r0, #0]
 800124e:	4023      	ands	r3, r4
 8001250:	ea43 0308 	orr.w	r3, r3, r8
    if (!mask)
 8001254:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
 8001256:	6003      	str	r3, [r0, #0]
    if (!mask)
 8001258:	d1c2      	bne.n	80011e0 <_pal_lld_setgroupmode+0x40>
  }
}
 800125a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800125e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001260:	401d      	ands	r5, r3
 8001262:	432c      	orrs	r4, r5
 8001264:	6244      	str	r4, [r0, #36]	; 0x24
 8001266:	e7b9      	b.n	80011dc <_pal_lld_setgroupmode+0x3c>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001268:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 800126c:	ea0b 0505 	and.w	r5, fp, r5
 8001270:	432c      	orrs	r4, r5
 8001272:	6244      	str	r4, [r0, #36]	; 0x24
 8001274:	e7ea      	b.n	800124c <_pal_lld_setgroupmode+0xac>
 8001276:	bf00      	nop
	...

08001280 <VectorB0>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001280:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001284:	691a      	ldr	r2, [r3, #16]
 8001286:	0792      	lsls	r2, r2, #30
 8001288:	d401      	bmi.n	800128e <VectorB0+0xe>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 800128a:	f001 b899 	b.w	80023c0 <_port_irq_epilogue>
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800128e:	b510      	push	{r4, lr}
    STM32_ST_TIM->SR = 0U;
 8001290:	2400      	movs	r4, #0
 8001292:	611c      	str	r4, [r3, #16]
 8001294:	2320      	movs	r3, #32
 8001296:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 800129a:	f000 fa91 	bl	80017c0 <chSysTimerHandlerI>
 800129e:	f384 8811 	msr	BASEPRI, r4
}
 80012a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80012a6:	f001 b88b 	b.w	80023c0 <_port_irq_epilogue>
 80012aa:	bf00      	nop
 80012ac:	0000      	movs	r0, r0
	...

080012b0 <st_lld_init>:

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80012b0:	4b11      	ldr	r3, [pc, #68]	; (80012f8 <st_lld_init+0x48>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80012b2:	4812      	ldr	r0, [pc, #72]	; (80012fc <st_lld_init+0x4c>)
  ST_ENABLE_CLOCK();
 80012b4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80012b6:	f042 0201 	orr.w	r2, r2, #1
void st_lld_init(void) {
 80012ba:	b470      	push	{r4, r5, r6}
  ST_ENABLE_CLOCK();
 80012bc:	641a      	str	r2, [r3, #64]	; 0x40
 80012be:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80012c0:	f042 0201 	orr.w	r2, r2, #1
 80012c4:	661a      	str	r2, [r3, #96]	; 0x60
  ST_ENABLE_STOP();
 80012c6:	6881      	ldr	r1, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80012c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 80012cc:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80012ce:	2401      	movs	r4, #1
  ST_ENABLE_STOP();
 80012d0:	f041 0101 	orr.w	r1, r1, #1
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80012d4:	f242 06cf 	movw	r6, #8399	; 0x20cf
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80012d8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  ST_ENABLE_STOP();
 80012dc:	6081      	str	r1, [r0, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80012de:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80012e0:	2108      	movs	r1, #8
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80012e2:	62dd      	str	r5, [r3, #44]	; 0x2c
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80012e4:	201c      	movs	r0, #28
  STM32_ST_TIM->CCMR1  = 0;
 80012e6:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80012e8:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80012ea:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80012ec:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80012ee:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80012f0:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80012f2:	bc70      	pop	{r4, r5, r6}
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80012f4:	f7ff be54 	b.w	8000fa0 <nvicEnableVector>
 80012f8:	40023800 	.word	0x40023800
 80012fc:	e0042000 	.word	0xe0042000

08001300 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8001300:	b510      	push	{r4, lr}
  PWMD3.tim = STM32_TIM3;
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
 8001302:	4c04      	ldr	r4, [pc, #16]	; (8001314 <pwm_lld_init+0x14>)
 8001304:	4620      	mov	r0, r4
 8001306:	f7ff fda3 	bl	8000e50 <pwmObjectInit>
  PWMD4.channels = STM32_TIM4_CHANNELS;
 800130a:	2204      	movs	r2, #4
  PWMD4.tim = STM32_TIM4;
 800130c:	4b02      	ldr	r3, [pc, #8]	; (8001318 <pwm_lld_init+0x18>)
  PWMD4.channels = STM32_TIM4_CHANNELS;
 800130e:	7422      	strb	r2, [r4, #16]
  PWMD4.tim = STM32_TIM4;
 8001310:	61a3      	str	r3, [r4, #24]
  /* Driver initialization.*/
  pwmObjectInit(&PWMD9);
  PWMD9.channels = STM32_TIM9_CHANNELS;
  PWMD9.tim = STM32_TIM9;
#endif
}
 8001312:	bd10      	pop	{r4, pc}
 8001314:	20000810 	.word	0x20000810
 8001318:	40000800 	.word	0x40000800
 800131c:	00000000 	.word	0x00000000

08001320 <pwm_lld_serve_interrupt>:
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8001320:	6983      	ldr	r3, [r0, #24]
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8001322:	b570      	push	{r4, r5, r6, lr}
  sr  = pwmp->tim->SR;
 8001324:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001326:	68dc      	ldr	r4, [r3, #12]
 8001328:	4014      	ands	r4, r2
 800132a:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 800132c:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800132e:	07a6      	lsls	r6, r4, #30
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8001330:	4605      	mov	r5, r0
  pwmp->tim->SR = ~sr;
 8001332:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8001334:	d503      	bpl.n	800133e <pwm_lld_serve_interrupt+0x1e>
      (pwmp->config->channels[0].callback != NULL))
 8001336:	6843      	ldr	r3, [r0, #4]
 8001338:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800133a:	b103      	cbz	r3, 800133e <pwm_lld_serve_interrupt+0x1e>
    pwmp->config->channels[0].callback(pwmp);
 800133c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800133e:	0760      	lsls	r0, r4, #29
 8001340:	d504      	bpl.n	800134c <pwm_lld_serve_interrupt+0x2c>
      (pwmp->config->channels[1].callback != NULL))
 8001342:	686b      	ldr	r3, [r5, #4]
 8001344:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001346:	b10b      	cbz	r3, 800134c <pwm_lld_serve_interrupt+0x2c>
    pwmp->config->channels[1].callback(pwmp);
 8001348:	4628      	mov	r0, r5
 800134a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800134c:	0721      	lsls	r1, r4, #28
 800134e:	d504      	bpl.n	800135a <pwm_lld_serve_interrupt+0x3a>
      (pwmp->config->channels[2].callback != NULL))
 8001350:	686b      	ldr	r3, [r5, #4]
 8001352:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001354:	b10b      	cbz	r3, 800135a <pwm_lld_serve_interrupt+0x3a>
    pwmp->config->channels[2].callback(pwmp);
 8001356:	4628      	mov	r0, r5
 8001358:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800135a:	06e2      	lsls	r2, r4, #27
 800135c:	d504      	bpl.n	8001368 <pwm_lld_serve_interrupt+0x48>
      (pwmp->config->channels[3].callback != NULL))
 800135e:	686b      	ldr	r3, [r5, #4]
 8001360:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001362:	b10b      	cbz	r3, 8001368 <pwm_lld_serve_interrupt+0x48>
    pwmp->config->channels[3].callback(pwmp);
 8001364:	4628      	mov	r0, r5
 8001366:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8001368:	07e3      	lsls	r3, r4, #31
 800136a:	d506      	bpl.n	800137a <pwm_lld_serve_interrupt+0x5a>
 800136c:	686b      	ldr	r3, [r5, #4]
 800136e:	689b      	ldr	r3, [r3, #8]
 8001370:	b11b      	cbz	r3, 800137a <pwm_lld_serve_interrupt+0x5a>
    pwmp->config->callback(pwmp);
 8001372:	4628      	mov	r0, r5
}
 8001374:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
 8001378:	4718      	bx	r3
}
 800137a:	bd70      	pop	{r4, r5, r6, pc}
 800137c:	0000      	movs	r0, r0
	...

08001380 <VectorB8>:
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8001380:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD4);
 8001382:	4803      	ldr	r0, [pc, #12]	; (8001390 <VectorB8+0x10>)
 8001384:	f7ff ffcc 	bl	8001320 <pwm_lld_serve_interrupt>
}
 8001388:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 800138c:	f001 b818 	b.w	80023c0 <_port_irq_epilogue>
 8001390:	20000810 	.word	0x20000810
	...

080013a0 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80013a0:	4a02      	ldr	r2, [pc, #8]	; (80013ac <notify1+0xc>)
 80013a2:	68d3      	ldr	r3, [r2, #12]
 80013a4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80013a8:	60d3      	str	r3, [r2, #12]
}
 80013aa:	4770      	bx	lr
 80013ac:	40011000 	.word	0x40011000

080013b0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 80013b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  USART_TypeDef *u = sdp->usart;
 80013b4:	4e46      	ldr	r6, [pc, #280]	; (80014d0 <VectorD4+0x120>)
 80013b6:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 80013b8:	f8d5 800c 	ldr.w	r8, [r5, #12]
  uint16_t sr = u->SR;
 80013bc:	682b      	ldr	r3, [r5, #0]
  if (sr & USART_SR_LBD) {
 80013be:	05da      	lsls	r2, r3, #23
  uint16_t sr = u->SR;
 80013c0:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 80013c2:	d450      	bmi.n	8001466 <VectorD4+0xb6>
 80013c4:	2320      	movs	r3, #32
 80013c6:	f383 8811 	msr	BASEPRI, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80013ca:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80013ce:	d02f      	beq.n	8001430 <VectorD4+0x80>
  chEvtBroadcastFlagsI(esp, flags);
 80013d0:	4f40      	ldr	r7, [pc, #256]	; (80014d4 <VectorD4+0x124>)
      sdIncomingDataI(sdp, b);
 80013d2:	f1a7 0904 	sub.w	r9, r7, #4
 80013d6:	e007      	b.n	80013e8 <VectorD4+0x38>
    if (sr & USART_SR_RXNE)
 80013d8:	06a0      	lsls	r0, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 80013da:	686b      	ldr	r3, [r5, #4]
    if (sr & USART_SR_RXNE)
 80013dc:	d41d      	bmi.n	800141a <VectorD4+0x6a>
    sr = u->SR;
 80013de:	682c      	ldr	r4, [r5, #0]
 80013e0:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80013e2:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80013e6:	d023      	beq.n	8001430 <VectorD4+0x80>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80013e8:	0723      	lsls	r3, r4, #28
 80013ea:	d0f5      	beq.n	80013d8 <VectorD4+0x28>
    sts |= SD_OVERRUN_ERROR;
 80013ec:	f014 0f08 	tst.w	r4, #8
 80013f0:	bf0c      	ite	eq
 80013f2:	2100      	moveq	r1, #0
 80013f4:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 80013f6:	07e0      	lsls	r0, r4, #31
    sts |= SD_PARITY_ERROR;
 80013f8:	bf48      	it	mi
 80013fa:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 80013fe:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8001400:	bf48      	it	mi
 8001402:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8001406:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8001408:	bf48      	it	mi
 800140a:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 800140e:	4638      	mov	r0, r7
 8001410:	f000 fe6e 	bl	80020f0 <chEvtBroadcastFlagsI>
    if (sr & USART_SR_RXNE)
 8001414:	06a0      	lsls	r0, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 8001416:	686b      	ldr	r3, [r5, #4]
    if (sr & USART_SR_RXNE)
 8001418:	d5e1      	bpl.n	80013de <VectorD4+0x2e>
    b = (uint8_t)u->DR & sdp->rxmask;
 800141a:	f896 1078 	ldrb.w	r1, [r6, #120]	; 0x78
      sdIncomingDataI(sdp, b);
 800141e:	4648      	mov	r0, r9
 8001420:	4019      	ands	r1, r3
 8001422:	f7ff fd9d 	bl	8000f60 <sdIncomingDataI>
    sr = u->SR;
 8001426:	682c      	ldr	r4, [r5, #0]
 8001428:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800142a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800142e:	d1db      	bne.n	80013e8 <VectorD4+0x38>
 8001430:	2300      	movs	r3, #0
 8001432:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8001436:	f018 0f80 	tst.w	r8, #128	; 0x80
 800143a:	d001      	beq.n	8001440 <VectorD4+0x90>
 800143c:	0622      	lsls	r2, r4, #24
 800143e:	d421      	bmi.n	8001484 <VectorD4+0xd4>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8001440:	f018 0f40 	tst.w	r8, #64	; 0x40
 8001444:	d00b      	beq.n	800145e <VectorD4+0xae>
 8001446:	0663      	lsls	r3, r4, #25
 8001448:	d509      	bpl.n	800145e <VectorD4+0xae>
 800144a:	2320      	movs	r3, #32
 800144c:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8001450:	e9d6 2311 	ldrd	r2, r3, [r6, #68]	; 0x44
 8001454:	429a      	cmp	r2, r3
 8001456:	d022      	beq.n	800149e <VectorD4+0xee>
 8001458:	2300      	movs	r3, #0
 800145a:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 800145e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
 8001462:	f000 bfad 	b.w	80023c0 <_port_irq_epilogue>
 8001466:	2320      	movs	r3, #32
 8001468:	f383 8811 	msr	BASEPRI, r3
 800146c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001470:	1d30      	adds	r0, r6, #4
 8001472:	f000 fe3d 	bl	80020f0 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8001476:	f46f 7380 	mvn.w	r3, #256	; 0x100
 800147a:	602b      	str	r3, [r5, #0]
 800147c:	2300      	movs	r3, #0
 800147e:	f383 8811 	msr	BASEPRI, r3
 8001482:	e79f      	b.n	80013c4 <VectorD4+0x14>
 8001484:	2320      	movs	r3, #32
 8001486:	f383 8811 	msr	BASEPRI, r3
    b = oqGetI(&sdp->oqueue);
 800148a:	4813      	ldr	r0, [pc, #76]	; (80014d8 <VectorD4+0x128>)
 800148c:	f7ff fc80 	bl	8000d90 <oqGetI>
    if (b < MSG_OK) {
 8001490:	2800      	cmp	r0, #0
 8001492:	db11      	blt.n	80014b8 <VectorD4+0x108>
      u->DR = b;
 8001494:	6068      	str	r0, [r5, #4]
 8001496:	2300      	movs	r3, #0
 8001498:	f383 8811 	msr	BASEPRI, r3
 800149c:	e7d0      	b.n	8001440 <VectorD4+0x90>
    if (oqIsEmptyI(&sdp->oqueue)) {
 800149e:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 80014a0:	2b00      	cmp	r3, #0
 80014a2:	d0d9      	beq.n	8001458 <VectorD4+0xa8>
 80014a4:	2110      	movs	r1, #16
 80014a6:	480b      	ldr	r0, [pc, #44]	; (80014d4 <VectorD4+0x124>)
 80014a8:	f000 fe22 	bl	80020f0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 80014ac:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 80014b0:	ea08 0303 	and.w	r3, r8, r3
 80014b4:	60eb      	str	r3, [r5, #12]
 80014b6:	e7cf      	b.n	8001458 <VectorD4+0xa8>
 80014b8:	2108      	movs	r1, #8
 80014ba:	4806      	ldr	r0, [pc, #24]	; (80014d4 <VectorD4+0x124>)
 80014bc:	f000 fe18 	bl	80020f0 <chEvtBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80014c0:	f64f 733f 	movw	r3, #65343	; 0xff3f
 80014c4:	ea08 0303 	and.w	r3, r8, r3
 80014c8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80014cc:	60eb      	str	r3, [r5, #12]
 80014ce:	e7e2      	b.n	8001496 <VectorD4+0xe6>
 80014d0:	2000082c 	.word	0x2000082c
 80014d4:	20000830 	.word	0x20000830
 80014d8:	2000085c 	.word	0x2000085c
 80014dc:	00000000 	.word	0x00000000

080014e0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80014e0:	b510      	push	{r4, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 80014e2:	4c04      	ldr	r4, [pc, #16]	; (80014f4 <sd_lld_init+0x14>)
 80014e4:	4a04      	ldr	r2, [pc, #16]	; (80014f8 <sd_lld_init+0x18>)
 80014e6:	4620      	mov	r0, r4
 80014e8:	2100      	movs	r1, #0
 80014ea:	f7ff fd09 	bl	8000f00 <sdObjectInit>
  SD1.usart = USART1;
 80014ee:	4b03      	ldr	r3, [pc, #12]	; (80014fc <sd_lld_init+0x1c>)
 80014f0:	6763      	str	r3, [r4, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 80014f2:	bd10      	pop	{r4, pc}
 80014f4:	2000082c 	.word	0x2000082c
 80014f8:	080013a1 	.word	0x080013a1
 80014fc:	40011000 	.word	0x40011000

08001500 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001500:	b570      	push	{r4, r5, r6, lr}

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001502:	7a03      	ldrb	r3, [r0, #8]
    config = &default_config;
 8001504:	4c22      	ldr	r4, [pc, #136]	; (8001590 <sd_lld_start+0x90>)
 8001506:	2900      	cmp	r1, #0
 8001508:	bf18      	it	ne
 800150a:	460c      	movne	r4, r1
  if (sdp->state == SD_STOP) {
 800150c:	2b01      	cmp	r3, #1
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800150e:	4605      	mov	r5, r0
  if (sdp->state == SD_STOP) {
 8001510:	d02d      	beq.n	800156e <sd_lld_start+0x6e>
  USART_TypeDef *u = sdp->usart;
 8001512:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8001514:	4a1f      	ldr	r2, [pc, #124]	; (8001594 <sd_lld_start+0x94>)
 8001516:	6821      	ldr	r1, [r4, #0]
 8001518:	4293      	cmp	r3, r2
 800151a:	d008      	beq.n	800152e <sd_lld_start+0x2e>
 800151c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001520:	4293      	cmp	r3, r2
 8001522:	d004      	beq.n	800152e <sd_lld_start+0x2e>
    u->BRR = STM32_PCLK1 / config->speed;
 8001524:	4a1c      	ldr	r2, [pc, #112]	; (8001598 <sd_lld_start+0x98>)
 8001526:	fbb2 f2f1 	udiv	r2, r2, r1
 800152a:	609a      	str	r2, [r3, #8]
 800152c:	e003      	b.n	8001536 <sd_lld_start+0x36>
    u->BRR = STM32_PCLK2 / config->speed;
 800152e:	4a1b      	ldr	r2, [pc, #108]	; (800159c <sd_lld_start+0x9c>)
 8001530:	fbb2 f2f1 	udiv	r2, r2, r1
 8001534:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001536:	88a2      	ldrh	r2, [r4, #4]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001538:	88e6      	ldrh	r6, [r4, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800153a:	8920      	ldrh	r0, [r4, #8]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800153c:	f442 5104 	orr.w	r1, r2, #8448	; 0x2100
 8001540:	f041 012c 	orr.w	r1, r1, #44	; 0x2c
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001544:	f046 0640 	orr.w	r6, r6, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001548:	f040 0001 	orr.w	r0, r0, #1
  u->SR = 0;
 800154c:	2400      	movs	r4, #0
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 800154e:	f402 52a0 	and.w	r2, r2, #5120	; 0x1400
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001552:	611e      	str	r6, [r3, #16]
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8001554:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001558:	6158      	str	r0, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800155a:	60d9      	str	r1, [r3, #12]
  u->SR = 0;
 800155c:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 800155e:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8001560:	685b      	ldr	r3, [r3, #4]
    sdp->rxmask = 0x7F;
 8001562:	bf0c      	ite	eq
 8001564:	237f      	moveq	r3, #127	; 0x7f
    sdp->rxmask = 0xFF;
 8001566:	23ff      	movne	r3, #255	; 0xff
 8001568:	f885 3078 	strb.w	r3, [r5, #120]	; 0x78
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
}
 800156c:	bd70      	pop	{r4, r5, r6, pc}
    if (&SD1 == sdp) {
 800156e:	4b0c      	ldr	r3, [pc, #48]	; (80015a0 <sd_lld_start+0xa0>)
 8001570:	4298      	cmp	r0, r3
 8001572:	d1ce      	bne.n	8001512 <sd_lld_start+0x12>
      rccEnableUSART1(true);
 8001574:	4b0b      	ldr	r3, [pc, #44]	; (80015a4 <sd_lld_start+0xa4>)
 8001576:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001578:	f042 0210 	orr.w	r2, r2, #16
 800157c:	645a      	str	r2, [r3, #68]	; 0x44
 800157e:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001580:	f042 0210 	orr.w	r2, r2, #16
 8001584:	665a      	str	r2, [r3, #100]	; 0x64
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8001586:	210c      	movs	r1, #12
 8001588:	2025      	movs	r0, #37	; 0x25
 800158a:	f7ff fd09 	bl	8000fa0 <nvicEnableVector>
 800158e:	e7c0      	b.n	8001512 <sd_lld_start+0x12>
 8001590:	080032f4 	.word	0x080032f4
 8001594:	40011000 	.word	0x40011000
 8001598:	0280de80 	.word	0x0280de80
 800159c:	0501bd00 	.word	0x0501bd00
 80015a0:	2000082c 	.word	0x2000082c
 80015a4:	40023800 	.word	0x40023800
	...

080015b0 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80015b0:	4a43      	ldr	r2, [pc, #268]	; (80016c0 <__early_init+0x110>)
  gpiop->OTYPER  = config->otyper;
 80015b2:	4944      	ldr	r1, [pc, #272]	; (80016c4 <__early_init+0x114>)
 80015b4:	4844      	ldr	r0, [pc, #272]	; (80016c8 <__early_init+0x118>)
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80015b6:	b5f0      	push	{r4, r5, r6, r7, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80015b8:	6916      	ldr	r6, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 80015ba:	4d44      	ldr	r5, [pc, #272]	; (80016cc <__early_init+0x11c>)
 80015bc:	4c44      	ldr	r4, [pc, #272]	; (80016d0 <__early_init+0x120>)
 80015be:	4f45      	ldr	r7, [pc, #276]	; (80016d4 <__early_init+0x124>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80015c0:	f240 1cff 	movw	ip, #511	; 0x1ff
 80015c4:	2300      	movs	r3, #0
 80015c6:	ea46 060c 	orr.w	r6, r6, ip
 80015ca:	6116      	str	r6, [r2, #16]
 80015cc:	6113      	str	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80015ce:	6b16      	ldr	r6, [r2, #48]	; 0x30
 80015d0:	ea46 060c 	orr.w	r6, r6, ip
 80015d4:	6316      	str	r6, [r2, #48]	; 0x30
 80015d6:	6d16      	ldr	r6, [r2, #80]	; 0x50
 80015d8:	ea46 060c 	orr.w	r6, r6, ip
 80015dc:	6516      	str	r6, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 80015de:	f46f 4ea8 	mvn.w	lr, #21504	; 0x5400
  gpiop->PUPDR   = config->pupdr;
 80015e2:	4e3d      	ldr	r6, [pc, #244]	; (80016d8 <__early_init+0x128>)
  gpiop->OTYPER  = config->otyper;
 80015e4:	604b      	str	r3, [r1, #4]
  gpiop->ODR     = config->odr;
 80015e6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
 80015ea:	f8c1 e008 	str.w	lr, [r1, #8]
  gpiop->AFRL    = config->afrl;
 80015ee:	f8df c110 	ldr.w	ip, [pc, #272]	; 8001700 <__early_init+0x150>
  gpiop->PUPDR   = config->pupdr;
 80015f2:	60ce      	str	r6, [r1, #12]
  gpiop->AFRH    = config->afrh;
 80015f4:	4e39      	ldr	r6, [pc, #228]	; (80016dc <__early_init+0x12c>)
  gpiop->ODR     = config->odr;
 80015f6:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80015f8:	f8c1 c020 	str.w	ip, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80015fc:	624e      	str	r6, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80015fe:	f8df c104 	ldr.w	ip, [pc, #260]	; 8001704 <__early_init+0x154>
 8001602:	f8c1 c000 	str.w	ip, [r1]
  gpiop->OTYPER  = config->otyper;
 8001606:	f44f 7610 	mov.w	r6, #576	; 0x240
 800160a:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800160c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  gpiop->PUPDR   = config->pupdr;
 8001610:	f8df c0f4 	ldr.w	ip, [pc, #244]	; 8001708 <__early_init+0x158>
  gpiop->OSPEEDR = config->ospeedr;
 8001614:	60a9      	str	r1, [r5, #8]
  gpiop->AFRL    = config->afrl;
 8001616:	f04f 6680 	mov.w	r6, #67108864	; 0x4000000
  gpiop->PUPDR   = config->pupdr;
 800161a:	f8c5 c00c 	str.w	ip, [r5, #12]
  gpiop->ODR     = config->odr;
 800161e:	616a      	str	r2, [r5, #20]
  gpiop->AFRH    = config->afrh;
 8001620:	f04f 0c40 	mov.w	ip, #64	; 0x40
  gpiop->AFRL    = config->afrl;
 8001624:	622e      	str	r6, [r5, #32]
  gpiop->MODER   = config->moder;
 8001626:	4e2e      	ldr	r6, [pc, #184]	; (80016e0 <__early_init+0x130>)
  gpiop->AFRH    = config->afrh;
 8001628:	f8c5 c024 	str.w	ip, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800162c:	602e      	str	r6, [r5, #0]
  gpiop->PUPDR   = config->pupdr;
 800162e:	f105 55a2 	add.w	r5, r5, #339738624	; 0x14400000
 8001632:	f505 3544 	add.w	r5, r5, #200704	; 0x31000
 8001636:	f505 75aa 	add.w	r5, r5, #340	; 0x154
  gpiop->OTYPER  = config->otyper;
 800163a:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800163c:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 800163e:	60e5      	str	r5, [r4, #12]
  gpiop->AFRL    = config->afrl;
 8001640:	f04f 45c0 	mov.w	r5, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 8001644:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8001646:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8001648:	4d26      	ldr	r5, [pc, #152]	; (80016e4 <__early_init+0x134>)
 800164a:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800164c:	4d26      	ldr	r5, [pc, #152]	; (80016e8 <__early_init+0x138>)
 800164e:	6025      	str	r5, [r4, #0]
  gpiop->PUPDR   = config->pupdr;
 8001650:	4c26      	ldr	r4, [pc, #152]	; (80016ec <__early_init+0x13c>)
  gpiop->OTYPER  = config->otyper;
 8001652:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001654:	6081      	str	r1, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8001656:	60c4      	str	r4, [r0, #12]
  gpiop->ODR     = config->odr;
 8001658:	f640 74ff 	movw	r4, #4095	; 0xfff
 800165c:	6144      	str	r4, [r0, #20]
  gpiop->MODER   = config->moder;
 800165e:	4c24      	ldr	r4, [pc, #144]	; (80016f0 <__early_init+0x140>)
  gpiop->AFRL    = config->afrl;
 8001660:	6203      	str	r3, [r0, #32]
  gpiop->OTYPER  = config->otyper;
 8001662:	4e24      	ldr	r6, [pc, #144]	; (80016f4 <__early_init+0x144>)
  gpiop->AFRH    = config->afrh;
 8001664:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->OTYPER  = config->otyper;
 8001666:	4d24      	ldr	r5, [pc, #144]	; (80016f8 <__early_init+0x148>)
  gpiop->MODER   = config->moder;
 8001668:	6004      	str	r4, [r0, #0]
  gpiop->OTYPER  = config->otyper;
 800166a:	4c24      	ldr	r4, [pc, #144]	; (80016fc <__early_init+0x14c>)
 800166c:	607b      	str	r3, [r7, #4]
 800166e:	f500 50a0 	add.w	r0, r0, #5120	; 0x1400
  gpiop->OSPEEDR = config->ospeedr;
 8001672:	60b9      	str	r1, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8001674:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 8001676:	617a      	str	r2, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8001678:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 800167a:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800167c:	f8c7 c000 	str.w	ip, [r7]
  gpiop->OTYPER  = config->otyper;
 8001680:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001682:	60b1      	str	r1, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8001684:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8001686:	6172      	str	r2, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8001688:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 800168a:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800168c:	6033      	str	r3, [r6, #0]
  gpiop->OTYPER  = config->otyper;
 800168e:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001690:	60a9      	str	r1, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8001692:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 8001694:	616a      	str	r2, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8001696:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8001698:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800169a:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 800169c:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800169e:	60a1      	str	r1, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80016a0:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 80016a2:	6162      	str	r2, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80016a4:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80016a6:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80016a8:	6023      	str	r3, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 80016aa:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80016ac:	6081      	str	r1, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80016ae:	60c3      	str	r3, [r0, #12]

  stm32_gpio_init();
  stm32_clock_init();
}
 80016b0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  gpiop->ODR     = config->odr;
 80016b4:	6142      	str	r2, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80016b6:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80016b8:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80016ba:	6003      	str	r3, [r0, #0]
  stm32_clock_init();
 80016bc:	f7ff bcf0 	b.w	80010a0 <stm32_clock_init>
 80016c0:	40023800 	.word	0x40023800
 80016c4:	40020000 	.word	0x40020000
 80016c8:	40020c00 	.word	0x40020c00
 80016cc:	40020400 	.word	0x40020400
 80016d0:	40020800 	.word	0x40020800
 80016d4:	40021000 	.word	0x40021000
 80016d8:	40010054 	.word	0x40010054
 80016dc:	000aaa00 	.word	0x000aaa00
 80016e0:	00082080 	.word	0x00082080
 80016e4:	00060600 	.word	0x00060600
 80016e8:	02208001 	.word	0x02208001
 80016ec:	00555055 	.word	0x00555055
 80016f0:	55000100 	.word	0x55000100
 80016f4:	40021400 	.word	0x40021400
 80016f8:	40021800 	.word	0x40021800
 80016fc:	40021c00 	.word	0x40021c00
 8001700:	55560000 	.word	0x55560000
 8001704:	2aa0aa00 	.word	0x2aa0aa00
 8001708:	55514515 	.word	0x55514515
 800170c:	00000000 	.word	0x00000000

08001710 <boardInit>:
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {

}
 8001710:	4770      	bx	lr
 8001712:	bf00      	nop
	...

08001720 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001720:	e7fe      	b.n	8001720 <_idle_thread>
 8001722:	bf00      	nop
	...

08001730 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001730:	b570      	push	{r4, r5, r6, lr}
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001732:	4c1c      	ldr	r4, [pc, #112]	; (80017a4 <chSysInit+0x74>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001734:	4e1c      	ldr	r6, [pc, #112]	; (80017a8 <chSysInit+0x78>)
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001736:	4d1d      	ldr	r5, [pc, #116]	; (80017ac <chSysInit+0x7c>)
  _scheduler_init();
 8001738:	f000 f95a 	bl	80019f0 <_scheduler_init>
  _vt_init();
 800173c:	f000 f890 	bl	8001860 <_vt_init>
  _tm_init();
 8001740:	f000 fbae 	bl	8001ea0 <_tm_init>
  _core_init();
 8001744:	f000 fcec 	bl	8002120 <_core_init>
  _heap_init();
 8001748:	f000 fd4a 	bl	80021e0 <_heap_init>
  _factory_init();
 800174c:	f000 fe00 	bl	8002350 <_factory_init>
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001750:	4620      	mov	r0, r4
 8001752:	2280      	movs	r2, #128	; 0x80
 8001754:	4916      	ldr	r1, [pc, #88]	; (80017b0 <chSysInit+0x80>)
 8001756:	f000 fa2b 	bl	8001bb0 <_thread_init>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800175a:	4b16      	ldr	r3, [pc, #88]	; (80017b4 <chSysInit+0x84>)
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 800175c:	2201      	movs	r2, #1
 800175e:	f880 2020 	strb.w	r2, [r0, #32]
 8001762:	68d9      	ldr	r1, [r3, #12]
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001764:	f844 0c18 	str.w	r0, [r4, #-24]
  currp->wabase = NULL;
 8001768:	2400      	movs	r4, #0
 800176a:	61c4      	str	r4, [r0, #28]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800176c:	4a12      	ldr	r2, [pc, #72]	; (80017b8 <chSysInit+0x88>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800176e:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 8001772:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 8001774:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001776:	60da      	str	r2, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001778:	68f2      	ldr	r2, [r6, #12]
 800177a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800177e:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001780:	682a      	ldr	r2, [r5, #0]
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001782:	2010      	movs	r0, #16
 8001784:	f042 0201 	orr.w	r2, r2, #1
 8001788:	2120      	movs	r1, #32
 800178a:	602a      	str	r2, [r5, #0]
 800178c:	77d8      	strb	r0, [r3, #31]
 800178e:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
 8001792:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 8001796:	b662      	cpsie	i
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
 8001798:	4808      	ldr	r0, [pc, #32]	; (80017bc <chSysInit+0x8c>)
  }
#endif
}
 800179a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chThdCreate(&idle_descriptor);
 800179e:	f000 ba67 	b.w	8001c70 <chThdCreate>
 80017a2:	bf00      	nop
 80017a4:	200009b0 	.word	0x200009b0
 80017a8:	e000edf0 	.word	0xe000edf0
 80017ac:	e0001000 	.word	0xe0001000
 80017b0:	08003328 	.word	0x08003328
 80017b4:	e000ed00 	.word	0xe000ed00
 80017b8:	05fa0300 	.word	0x05fa0300
 80017bc:	08003300 	.word	0x08003300

080017c0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80017c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 80017c4:	f8df 9088 	ldr.w	r9, [pc, #136]	; 8001850 <chSysTimerHandlerI+0x90>
 80017c8:	464d      	mov	r5, r9
  return (systime_t)STM32_ST_TIM->CNT;
 80017ca:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 80017ce:	f855 4f1c 	ldr.w	r4, [r5, #28]!
 80017d2:	68a3      	ldr	r3, [r4, #8]
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 80017d4:	2600      	movs	r6, #0
 80017d6:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 80017da:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80017de:	eba1 0a02 	sub.w	sl, r1, r2
    if (nowdelta < vtp->delta) {
 80017e2:	459a      	cmp	sl, r3
 80017e4:	d31f      	bcc.n	8001826 <chSysTimerHandlerI+0x66>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80017e6:	2720      	movs	r7, #32
 80017e8:	e00c      	b.n	8001804 <chSysTimerHandlerI+0x44>
 80017ea:	f386 8811 	msr	BASEPRI, r6
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 80017ee:	6920      	ldr	r0, [r4, #16]
 80017f0:	47d8      	blx	fp
 80017f2:	f387 8811 	msr	BASEPRI, r7
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 80017f6:	f8d9 401c 	ldr.w	r4, [r9, #28]
    }
    while (vtp->delta <= nowdelta);
 80017fa:	68a3      	ldr	r3, [r4, #8]
 80017fc:	459a      	cmp	sl, r3
 80017fe:	d3ea      	bcc.n	80017d6 <chSysTimerHandlerI+0x16>
 8001800:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001804:	6821      	ldr	r1, [r4, #0]
      fn = vtp->func;
 8001806:	f8d4 b00c 	ldr.w	fp, [r4, #12]
      ch.vtlist.lasttime += vtp->delta;
 800180a:	441a      	add	r2, r3
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800180c:	42a9      	cmp	r1, r5
      ch.vtlist.lasttime += vtp->delta;
 800180e:	f8c9 2028 	str.w	r2, [r9, #40]	; 0x28
      nowdelta -= vtp->delta;
 8001812:	ebaa 0a03 	sub.w	sl, sl, r3
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001816:	604d      	str	r5, [r1, #4]
      ch.vtlist.next = vtp->next;
 8001818:	f8c9 101c 	str.w	r1, [r9, #28]
      vtp->func = NULL;
 800181c:	60e6      	str	r6, [r4, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800181e:	d1e4      	bne.n	80017ea <chSysTimerHandlerI+0x2a>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8001820:	f7ff f96e 	bl	8000b00 <stStopAlarm>
 8001824:	e7e1      	b.n	80017ea <chSysTimerHandlerI+0x2a>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001826:	f8d9 301c 	ldr.w	r3, [r9, #28]
 800182a:	42ab      	cmp	r3, r5
 800182c:	d00e      	beq.n	800184c <chSysTimerHandlerI+0x8c>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 800182e:	689a      	ldr	r2, [r3, #8]
  ch.vtlist.lasttime += nowdelta;
 8001830:	f8c9 1028 	str.w	r1, [r9, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8001834:	eba2 020a 	sub.w	r2, r2, sl
 8001838:	609a      	str	r2, [r3, #8]
  return systime + (systime_t)interval;
 800183a:	68a0      	ldr	r0, [r4, #8]
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800183c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001840:	2802      	cmp	r0, #2
 8001842:	bf2c      	ite	cs
 8001844:	1808      	addcs	r0, r1, r0
 8001846:	1c88      	addcc	r0, r1, #2
 8001848:	f7ff b962 	b.w	8000b10 <stSetAlarm>
 800184c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001850:	20000980 	.word	0x20000980
	...

08001860 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001860:	4b05      	ldr	r3, [pc, #20]	; (8001878 <_vt_init+0x18>)
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (sysinterval_t)-1;
 8001862:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001866:	2100      	movs	r1, #0
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001868:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.lasttime = (systime_t)0;
 800186c:	e9c3 0109 	strd	r0, r1, [r3, #36]	; 0x24
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001870:	e9c3 2207 	strd	r2, r2, [r3, #28]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001874:	4770      	bx	lr
 8001876:	bf00      	nop
 8001878:	20000980 	.word	0x20000980
 800187c:	00000000 	.word	0x00000000

08001880 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8001880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001882:	4f1f      	ldr	r7, [pc, #124]	; (8001900 <chVTDoSetI+0x80>)
 8001884:	46bc      	mov	ip, r7
 8001886:	2902      	cmp	r1, #2
 8001888:	f85c 5f1c 	ldr.w	r5, [ip, #28]!
  vtp->par = par;
 800188c:	6103      	str	r3, [r0, #16]
 800188e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001892:	bf38      	it	cc
 8001894:	2102      	movcc	r1, #2
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001896:	4565      	cmp	r5, ip
                vtfunc_t vtfunc, void *par) {
 8001898:	4606      	mov	r6, r0
  vtp->func = vtfunc;
 800189a:	60c2      	str	r2, [r0, #12]
 800189c:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800189e:	d01e      	beq.n	80018de <chVTDoSetI+0x5e>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80018a0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80018a2:	68ab      	ldr	r3, [r5, #8]
  return (sysinterval_t)((systime_t)(end - start));
 80018a4:	1a24      	subs	r4, r4, r0
 80018a6:	1864      	adds	r4, r4, r1

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80018a8:	d215      	bcs.n	80018d6 <chVTDoSetI+0x56>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 80018aa:	429c      	cmp	r4, r3
 80018ac:	d322      	bcc.n	80018f4 <chVTDoSetI+0x74>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 80018ae:	42a3      	cmp	r3, r4
 80018b0:	d204      	bcs.n	80018bc <chVTDoSetI+0x3c>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
 80018b2:	682d      	ldr	r5, [r5, #0]
    delta -= p->delta;
 80018b4:	1ae4      	subs	r4, r4, r3
  while (p->delta < delta) {
 80018b6:	68ab      	ldr	r3, [r5, #8]
 80018b8:	42a3      	cmp	r3, r4
 80018ba:	d3fa      	bcc.n	80018b2 <chVTDoSetI+0x32>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 80018bc:	686b      	ldr	r3, [r5, #4]
 80018be:	e9c6 5300 	strd	r5, r3, [r6]
  vtp->prev->next = vtp;
 80018c2:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
 80018c4:	606e      	str	r6, [r5, #4]
  vtp->delta = delta;
 80018c6:	60b4      	str	r4, [r6, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 80018c8:	68ab      	ldr	r3, [r5, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 80018ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  p->delta -= delta;
 80018ce:	1b1c      	subs	r4, r3, r4
 80018d0:	60ac      	str	r4, [r5, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 80018d2:	627a      	str	r2, [r7, #36]	; 0x24
}
 80018d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      p = p->next;
 80018d6:	682d      	ldr	r5, [r5, #0]
      delta -= p->delta;
 80018d8:	1ae4      	subs	r4, r4, r3
 80018da:	68ab      	ldr	r3, [r5, #8]
 80018dc:	e7e7      	b.n	80018ae <chVTDoSetI+0x2e>
      ch.vtlist.prev = vtp;
 80018de:	e9c7 0007 	strd	r0, r0, [r7, #28]
      ch.vtlist.lasttime = now;
 80018e2:	62bc      	str	r4, [r7, #40]	; 0x28
  stStartAlarm(time);
 80018e4:	1860      	adds	r0, r4, r1
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80018e6:	e9c6 5500 	strd	r5, r5, [r6]
      vtp->delta = delay;
 80018ea:	60b1      	str	r1, [r6, #8]
}
 80018ec:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80018f0:	f7ff b8fe 	b.w	8000af0 <stStartAlarm>
  stSetAlarm(time);
 80018f4:	4420      	add	r0, r4
 80018f6:	f7ff f90b 	bl	8000b10 <stSetAlarm>
 80018fa:	68ab      	ldr	r3, [r5, #8]
 80018fc:	e7d7      	b.n	80018ae <chVTDoSetI+0x2e>
 80018fe:	bf00      	nop
 8001900:	20000980 	.word	0x20000980
	...

08001910 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001910:	4b19      	ldr	r3, [pc, #100]	; (8001978 <chVTDoResetI+0x68>)
 8001912:	69da      	ldr	r2, [r3, #28]
 8001914:	4282      	cmp	r2, r0
void chVTDoResetI(virtual_timer_t *vtp) {
 8001916:	b410      	push	{r4}
  if (ch.vtlist.next != vtp) {
 8001918:	d00f      	beq.n	800193a <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800191a:	e9d0 2100 	ldrd	r2, r1, [r0]
 800191e:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8001920:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001922:	331c      	adds	r3, #28
    vtp->func = NULL;
 8001924:	2400      	movs	r4, #0
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001926:	429a      	cmp	r2, r3
    vtp->next->prev = vtp->prev;
 8001928:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 800192a:	60c4      	str	r4, [r0, #12]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800192c:	d003      	beq.n	8001936 <chVTDoResetI+0x26>
      vtp->next->delta += vtp->delta;
 800192e:	6881      	ldr	r1, [r0, #8]
 8001930:	6893      	ldr	r3, [r2, #8]
 8001932:	440b      	add	r3, r1
 8001934:	6093      	str	r3, [r2, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001936:	bc10      	pop	{r4}
 8001938:	4770      	bx	lr
  ch.vtlist.next = vtp->next;
 800193a:	4618      	mov	r0, r3
 800193c:	6811      	ldr	r1, [r2, #0]
 800193e:	f840 1f1c 	str.w	r1, [r0, #28]!
  vtp->func = NULL;
 8001942:	2400      	movs	r4, #0
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001944:	4281      	cmp	r1, r0
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001946:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8001948:	60d4      	str	r4, [r2, #12]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800194a:	d012      	beq.n	8001972 <chVTDoResetI+0x62>
  ch.vtlist.next->delta += vtp->delta;
 800194c:	6894      	ldr	r4, [r2, #8]
 800194e:	688a      	ldr	r2, [r1, #8]
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8001950:	6a98      	ldr	r0, [r3, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8001952:	4414      	add	r4, r2
 8001954:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001958:	608c      	str	r4, [r1, #8]
 800195a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800195c:	1a12      	subs	r2, r2, r0
  if (nowdelta >= ch.vtlist.next->delta) {
 800195e:	4294      	cmp	r4, r2
 8001960:	d9e9      	bls.n	8001936 <chVTDoResetI+0x26>
  delta = ch.vtlist.next->delta - nowdelta;
 8001962:	1aa1      	subs	r1, r4, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001964:	2901      	cmp	r1, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001966:	bf98      	it	ls
 8001968:	1c94      	addls	r4, r2, #2
 800196a:	4420      	add	r0, r4
}
 800196c:	bc10      	pop	{r4}
 800196e:	f7ff b8cf 	b.w	8000b10 <stSetAlarm>
 8001972:	bc10      	pop	{r4}
  stStopAlarm();
 8001974:	f7ff b8c4 	b.w	8000b00 <stStopAlarm>
 8001978:	20000980 	.word	0x20000980
 800197c:	00000000 	.word	0x00000000

08001980 <wakeup>:
 8001980:	2320      	movs	r3, #32
 8001982:	f383 8811 	msr	BASEPRI, r3
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8001986:	f890 3020 	ldrb.w	r3, [r0, #32]
 800198a:	2b07      	cmp	r3, #7
 800198c:	d80e      	bhi.n	80019ac <wakeup+0x2c>
 800198e:	e8df f003 	tbb	[pc, r3]
 8001992:	0d28      	.short	0x0d28
 8001994:	0408240d 	.word	0x0408240d
 8001998:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800199a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800199c:	6893      	ldr	r3, [r2, #8]
 800199e:	3301      	adds	r3, #1
 80019a0:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80019a2:	e9d0 2300 	ldrd	r2, r3, [r0]
 80019a6:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80019a8:	6802      	ldr	r2, [r0, #0]
 80019aa:	6053      	str	r3, [r2, #4]
static void wakeup(void *p) {
 80019ac:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 80019ae:	2200      	movs	r2, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80019b0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  } while (cp->prio >= tp->prio);
 80019b4:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 80019b6:	4b0d      	ldr	r3, [pc, #52]	; (80019ec <wakeup+0x6c>)
  tp->u.rdymsg = MSG_TIMEOUT;
 80019b8:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 80019ba:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 80019be:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80019c0:	689a      	ldr	r2, [r3, #8]
 80019c2:	428a      	cmp	r2, r1
 80019c4:	d2fb      	bcs.n	80019be <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
 80019c6:	685a      	ldr	r2, [r3, #4]
 80019c8:	2100      	movs	r1, #0
 80019ca:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 80019ce:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80019d0:	6058      	str	r0, [r3, #4]
 80019d2:	f381 8811 	msr	BASEPRI, r1
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80019d6:	bc10      	pop	{r4}
 80019d8:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 80019da:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80019dc:	2200      	movs	r2, #0
 80019de:	601a      	str	r2, [r3, #0]
    break;
 80019e0:	e7e4      	b.n	80019ac <wakeup+0x2c>
 80019e2:	2300      	movs	r3, #0
 80019e4:	f383 8811 	msr	BASEPRI, r3
 80019e8:	4770      	bx	lr
 80019ea:	bf00      	nop
 80019ec:	20000980 	.word	0x20000980

080019f0 <_scheduler_init>:
  tqp->next = (thread_t *)tqp;
 80019f0:	4b03      	ldr	r3, [pc, #12]	; (8001a00 <_scheduler_init+0x10>)
  ch.rlist.prio = NOPRIO;
 80019f2:	2200      	movs	r2, #0
  tqp->prev = (thread_t *)tqp;
 80019f4:	e9c3 3300 	strd	r3, r3, [r3]
  ch.rlist.older = (thread_t *)&ch.rlist;
 80019f8:	e9c3 3304 	strd	r3, r3, [r3, #16]
  ch.rlist.prio = NOPRIO;
 80019fc:	609a      	str	r2, [r3, #8]
}
 80019fe:	4770      	bx	lr
 8001a00:	20000980 	.word	0x20000980
	...

08001a10 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8001a10:	4601      	mov	r1, r0
  tp->state = CH_STATE_READY;
 8001a12:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 8001a14:	4b07      	ldr	r3, [pc, #28]	; (8001a34 <chSchReadyI+0x24>)
  } while (cp->prio >= tp->prio);
 8001a16:	6880      	ldr	r0, [r0, #8]
  tp->state = CH_STATE_READY;
 8001a18:	f881 2020 	strb.w	r2, [r1, #32]
    cp = cp->queue.next;
 8001a1c:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001a1e:	689a      	ldr	r2, [r3, #8]
 8001a20:	4282      	cmp	r2, r0
 8001a22:	d2fb      	bcs.n	8001a1c <chSchReadyI+0xc>
  tp->queue.prev             = cp->queue.prev;
 8001a24:	685a      	ldr	r2, [r3, #4]
}
 8001a26:	4608      	mov	r0, r1
  tp->queue.prev             = cp->queue.prev;
 8001a28:	e9c1 3200 	strd	r3, r2, [r1]
  tp->queue.prev->queue.next = tp;
 8001a2c:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8001a2e:	6059      	str	r1, [r3, #4]
}
 8001a30:	4770      	bx	lr
 8001a32:	bf00      	nop
 8001a34:	20000980 	.word	0x20000980
	...

08001a40 <chSchGoSleepS>:
  thread_t *otp = currp;
 8001a40:	4b08      	ldr	r3, [pc, #32]	; (8001a64 <chSchGoSleepS+0x24>)
 8001a42:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->next;
 8001a44:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8001a46:	b410      	push	{r4}
  otp->state = newstate;
 8001a48:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 8001a4c:	6810      	ldr	r0, [r2, #0]
 8001a4e:	6018      	str	r0, [r3, #0]
  currp->state = CH_STATE_CURRENT;
 8001a50:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8001a52:	6043      	str	r3, [r0, #4]
 8001a54:	f882 4020 	strb.w	r4, [r2, #32]
  chSysSwitch(currp, otp);
 8001a58:	4610      	mov	r0, r2
}
 8001a5a:	bc10      	pop	{r4}
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001a5c:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 8001a5e:	f7fe bc37 	b.w	80002d0 <_port_switch>
 8001a62:	bf00      	nop
 8001a64:	20000980 	.word	0x20000980
	...

08001a70 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001a70:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 8001a72:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001a74:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8001a76:	d012      	beq.n	8001a9e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8001a78:	4c0c      	ldr	r4, [pc, #48]	; (8001aac <chSchGoSleepTimeoutS+0x3c>)
 8001a7a:	4a0d      	ldr	r2, [pc, #52]	; (8001ab0 <chSchGoSleepTimeoutS+0x40>)
 8001a7c:	69a3      	ldr	r3, [r4, #24]
 8001a7e:	4605      	mov	r5, r0
 8001a80:	a801      	add	r0, sp, #4
 8001a82:	f7ff fefd 	bl	8001880 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8001a86:	4628      	mov	r0, r5
 8001a88:	f7ff ffda 	bl	8001a40 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001a8c:	9b04      	ldr	r3, [sp, #16]
 8001a8e:	b113      	cbz	r3, 8001a96 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8001a90:	a801      	add	r0, sp, #4
 8001a92:	f7ff ff3d 	bl	8001910 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8001a96:	69a3      	ldr	r3, [r4, #24]
}
 8001a98:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001a9a:	b007      	add	sp, #28
 8001a9c:	bd30      	pop	{r4, r5, pc}
 8001a9e:	4c03      	ldr	r4, [pc, #12]	; (8001aac <chSchGoSleepTimeoutS+0x3c>)
    chSchGoSleepS(newstate);
 8001aa0:	f7ff ffce 	bl	8001a40 <chSchGoSleepS>
  return currp->u.rdymsg;
 8001aa4:	69a3      	ldr	r3, [r4, #24]
}
 8001aa6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001aa8:	b007      	add	sp, #28
 8001aaa:	bd30      	pop	{r4, r5, pc}
 8001aac:	20000980 	.word	0x20000980
 8001ab0:	08001981 	.word	0x08001981
	...

08001ac0 <chSchWakeupS>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8001ac0:	4b16      	ldr	r3, [pc, #88]	; (8001b1c <chSchWakeupS+0x5c>)
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001ac2:	b470      	push	{r4, r5, r6}
  thread_t *otp = currp;
 8001ac4:	699e      	ldr	r6, [r3, #24]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8001ac6:	6885      	ldr	r5, [r0, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001ac8:	4604      	mov	r4, r0
  if (ntp->prio <= otp->prio) {
 8001aca:	68b0      	ldr	r0, [r6, #8]
  ntp->u.rdymsg = msg;
 8001acc:	6261      	str	r1, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8001ace:	4285      	cmp	r5, r0
  tp->state = CH_STATE_READY;
 8001ad0:	f04f 0200 	mov.w	r2, #0
  if (ntp->prio <= otp->prio) {
 8001ad4:	d80c      	bhi.n	8001af0 <chSchWakeupS+0x30>
  tp->state = CH_STATE_READY;
 8001ad6:	f884 2020 	strb.w	r2, [r4, #32]
    cp = cp->queue.next;
 8001ada:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001adc:	689a      	ldr	r2, [r3, #8]
 8001ade:	4295      	cmp	r5, r2
 8001ae0:	d9fb      	bls.n	8001ada <chSchWakeupS+0x1a>
  tp->queue.prev             = cp->queue.prev;
 8001ae2:	685a      	ldr	r2, [r3, #4]
 8001ae4:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8001ae8:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001aea:	605c      	str	r4, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8001aec:	bc70      	pop	{r4, r5, r6}
 8001aee:	4770      	bx	lr
  tp->state = CH_STATE_READY;
 8001af0:	f886 2020 	strb.w	r2, [r6, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8001af4:	461a      	mov	r2, r3
    cp = cp->queue.next;
 8001af6:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8001af8:	6891      	ldr	r1, [r2, #8]
 8001afa:	4288      	cmp	r0, r1
 8001afc:	d9fb      	bls.n	8001af6 <chSchWakeupS+0x36>
  tp->queue.prev             = cp->queue.prev;
 8001afe:	6851      	ldr	r1, [r2, #4]
 8001b00:	6071      	str	r1, [r6, #4]
    ntp->state = CH_STATE_CURRENT;
 8001b02:	2001      	movs	r0, #1
  tp->queue.next             = cp;
 8001b04:	6032      	str	r2, [r6, #0]
  tp->queue.prev->queue.next = tp;
 8001b06:	600e      	str	r6, [r1, #0]
  cp->queue.prev             = tp;
 8001b08:	6056      	str	r6, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
 8001b0a:	f884 0020 	strb.w	r0, [r4, #32]
    chSysSwitch(ntp, otp);
 8001b0e:	4631      	mov	r1, r6
 8001b10:	4620      	mov	r0, r4
    currp = ntp;
 8001b12:	619c      	str	r4, [r3, #24]
}
 8001b14:	bc70      	pop	{r4, r5, r6}
    chSysSwitch(ntp, otp);
 8001b16:	f7fe bbdb 	b.w	80002d0 <_port_switch>
 8001b1a:	bf00      	nop
 8001b1c:	20000980 	.word	0x20000980

08001b20 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001b20:	4b04      	ldr	r3, [pc, #16]	; (8001b34 <chSchIsPreemptionRequired+0x14>)
 8001b22:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->prio;
 8001b24:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001b26:	6890      	ldr	r0, [r2, #8]
 8001b28:	689b      	ldr	r3, [r3, #8]
#endif
}
 8001b2a:	4298      	cmp	r0, r3
 8001b2c:	bf94      	ite	ls
 8001b2e:	2000      	movls	r0, #0
 8001b30:	2001      	movhi	r0, #1
 8001b32:	4770      	bx	lr
 8001b34:	20000980 	.word	0x20000980
	...

08001b40 <chSchDoRescheduleAhead>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 8001b40:	4b0d      	ldr	r3, [pc, #52]	; (8001b78 <chSchDoRescheduleAhead+0x38>)
  thread_t *tp = tqp->next;
 8001b42:	6818      	ldr	r0, [r3, #0]
  tqp->next             = tp->queue.next;
 8001b44:	6802      	ldr	r2, [r0, #0]
void chSchDoRescheduleAhead(void) {
 8001b46:	b410      	push	{r4}

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001b48:	2101      	movs	r1, #1
  thread_t *otp = currp;
 8001b4a:	699c      	ldr	r4, [r3, #24]
 8001b4c:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001b4e:	6053      	str	r3, [r2, #4]
  currp->state = CH_STATE_CURRENT;
 8001b50:	f880 1020 	strb.w	r1, [r0, #32]
  tp->state = CH_STATE_READY;
 8001b54:	2200      	movs	r2, #0

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8001b56:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8001b58:	f884 2020 	strb.w	r2, [r4, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001b5c:	6198      	str	r0, [r3, #24]
    cp = cp->queue.next;
 8001b5e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8001b60:	689a      	ldr	r2, [r3, #8]
 8001b62:	4291      	cmp	r1, r2
 8001b64:	d3fb      	bcc.n	8001b5e <chSchDoRescheduleAhead+0x1e>
  tp->queue.prev             = cp->queue.prev;
 8001b66:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001b68:	4621      	mov	r1, r4
  tp->queue.prev             = cp->queue.prev;
 8001b6a:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8001b6e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001b70:	605c      	str	r4, [r3, #4]
}
 8001b72:	bc10      	pop	{r4}
  chSysSwitch(currp, otp);
 8001b74:	f7fe bbac 	b.w	80002d0 <_port_switch>
 8001b78:	20000980 	.word	0x20000980
 8001b7c:	00000000 	.word	0x00000000

08001b80 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8001b80:	4b04      	ldr	r3, [pc, #16]	; (8001b94 <chSchRescheduleS+0x14>)
 8001b82:	681a      	ldr	r2, [r3, #0]
 8001b84:	699b      	ldr	r3, [r3, #24]
  if (chSchIsRescRequiredI()) {
 8001b86:	6892      	ldr	r2, [r2, #8]
 8001b88:	689b      	ldr	r3, [r3, #8]
 8001b8a:	429a      	cmp	r2, r3
 8001b8c:	d800      	bhi.n	8001b90 <chSchRescheduleS+0x10>
}
 8001b8e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8001b90:	f7ff bfd6 	b.w	8001b40 <chSchDoRescheduleAhead>
 8001b94:	20000980 	.word	0x20000980
	...

08001ba0 <chSchDoReschedule>:
 8001ba0:	f7ff bfce 	b.w	8001b40 <chSchDoRescheduleAhead>
	...

08001bb0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8001bb0:	b470      	push	{r4, r5, r6}
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001bb2:	4c0d      	ldr	r4, [pc, #52]	; (8001be8 <_thread_init+0x38>)
  tp->realprio  = prio;
 8001bb4:	63c2      	str	r2, [r0, #60]	; 0x3c
  REG_INSERT(tp);
 8001bb6:	6965      	ldr	r5, [r4, #20]
  tp->prio      = prio;
 8001bb8:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 8001bba:	2602      	movs	r6, #2
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001bbc:	2201      	movs	r2, #1
  tp->name      = name;
 8001bbe:	6181      	str	r1, [r0, #24]
  tp->state     = CH_STATE_WTSTART;
 8001bc0:	8406      	strh	r6, [r0, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001bc2:	f880 2022 	strb.w	r2, [r0, #34]	; 0x22
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8001bc6:	f100 0628 	add.w	r6, r0, #40	; 0x28
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8001bca:	f100 022c 	add.w	r2, r0, #44	; 0x2c
  tp->mtxlist   = NULL;
 8001bce:	2100      	movs	r1, #0
  REG_INSERT(tp);
 8001bd0:	6145      	str	r5, [r0, #20]
 8001bd2:	6104      	str	r4, [r0, #16]
  tp->epending  = (eventmask_t)0;
 8001bd4:	e9c0 110d 	strd	r1, r1, [r0, #52]	; 0x34
  REG_INSERT(tp);
 8001bd8:	6128      	str	r0, [r5, #16]
 8001bda:	6160      	str	r0, [r4, #20]
  tqp->next = (thread_t *)tqp;
 8001bdc:	e9c0 620a 	strd	r6, r2, [r0, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8001be0:	6302      	str	r2, [r0, #48]	; 0x30
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 8001be2:	bc70      	pop	{r4, r5, r6}
 8001be4:	4770      	bx	lr
 8001be6:	bf00      	nop
 8001be8:	20000980 	.word	0x20000980
 8001bec:	00000000 	.word	0x00000000

08001bf0 <chThdCreateSuspendedI>:
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8001bf0:	6883      	ldr	r3, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001bf2:	6841      	ldr	r1, [r0, #4]
  REG_INSERT(tp);
 8001bf4:	4a19      	ldr	r2, [pc, #100]	; (8001c5c <chThdCreateSuspendedI+0x6c>)
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8001bf6:	b4f0      	push	{r4, r5, r6, r7}
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001bf8:	e9d0 7504 	ldrd	r7, r5, [r0, #16]
  tp->state     = CH_STATE_WTSTART;
 8001bfc:	2602      	movs	r6, #2
  tp->wabase = tdp->wbase;
 8001bfe:	f843 1c2c 	str.w	r1, [r3, #-44]
  tp->refs      = (trefs_t)1;
 8001c02:	2401      	movs	r4, #1
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001c04:	2100      	movs	r1, #0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001c06:	e943 751b 	strd	r7, r5, [r3, #-108]	; 0x6c

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8001c0a:	6805      	ldr	r5, [r0, #0]
 8001c0c:	68c0      	ldr	r0, [r0, #12]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001c0e:	f803 1c27 	strb.w	r1, [r3, #-39]
  tp->state     = CH_STATE_WTSTART;
 8001c12:	f803 6c28 	strb.w	r6, [r3, #-40]
  tp->refs      = (trefs_t)1;
 8001c16:	f803 4c26 	strb.w	r4, [r3, #-38]
  REG_INSERT(tp);
 8001c1a:	6954      	ldr	r4, [r2, #20]
  tp->prio      = prio;
 8001c1c:	f843 0c40 	str.w	r0, [r3, #-64]
  tp->realprio  = prio;
 8001c20:	f843 0c0c 	str.w	r0, [r3, #-12]
  tp->name      = name;
 8001c24:	f843 5c30 	str.w	r5, [r3, #-48]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001c28:	f1a3 006c 	sub.w	r0, r3, #108	; 0x6c
 8001c2c:	4d0c      	ldr	r5, [pc, #48]	; (8001c60 <chThdCreateSuspendedI+0x70>)
 8001c2e:	f843 0c3c 	str.w	r0, [r3, #-60]
 8001c32:	f843 5c4c 	str.w	r5, [r3, #-76]
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8001c36:	f1a3 0048 	sub.w	r0, r3, #72	; 0x48
  tp->epending  = (eventmask_t)0;
 8001c3a:	e943 1105 	strd	r1, r1, [r3, #-20]
  list_init(&tp->waiting);
 8001c3e:	f1a3 0520 	sub.w	r5, r3, #32
  queue_init(&tp->msgqueue);
 8001c42:	f1a3 011c 	sub.w	r1, r3, #28
  REG_INSERT(tp);
 8001c46:	e943 240e 	strd	r2, r4, [r3, #-56]	; 0x38
 8001c4a:	6120      	str	r0, [r4, #16]
 8001c4c:	6150      	str	r0, [r2, #20]
  tqp->next = (thread_t *)tqp;
 8001c4e:	e943 5108 	strd	r5, r1, [r3, #-32]
  tqp->prev = (thread_t *)tqp;
 8001c52:	f843 1c18 	str.w	r1, [r3, #-24]
}
 8001c56:	bcf0      	pop	{r4, r5, r6, r7}
 8001c58:	4770      	bx	lr
 8001c5a:	bf00      	nop
 8001c5c:	20000980 	.word	0x20000980
 8001c60:	080002e1 	.word	0x080002e1
	...

08001c70 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8001c70:	b510      	push	{r4, lr}
 8001c72:	2320      	movs	r3, #32
 8001c74:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8001c78:	f7ff ffba 	bl	8001bf0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8001c7c:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
 8001c7e:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8001c80:	f7ff ff1e 	bl	8001ac0 <chSchWakeupS>
 8001c84:	2300      	movs	r3, #0
 8001c86:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8001c8a:	4620      	mov	r0, r4
 8001c8c:	bd10      	pop	{r4, pc}
 8001c8e:	bf00      	nop

08001c90 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001c90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001c92:	9d06      	ldr	r5, [sp, #24]
 8001c94:	2420      	movs	r4, #32
 8001c96:	f384 8811 	msr	BASEPRI, r4
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8001c9a:	3948      	subs	r1, #72	; 0x48
 8001c9c:	1844      	adds	r4, r0, r1
  REG_INSERT(tp);
 8001c9e:	4e16      	ldr	r6, [pc, #88]	; (8001cf8 <chThdCreateStatic+0x68>)
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8001ca0:	61e0      	str	r0, [r4, #28]
  REG_INSERT(tp);
 8001ca2:	6971      	ldr	r1, [r6, #20]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001ca4:	f844 3c24 	str.w	r3, [r4, #-36]
 8001ca8:	f844 5c20 	str.w	r5, [r4, #-32]
 8001cac:	f1a4 0024 	sub.w	r0, r4, #36	; 0x24
  tp->state     = CH_STATE_WTSTART;
 8001cb0:	2502      	movs	r5, #2
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001cb2:	2301      	movs	r3, #1
  tp->prio      = prio;
 8001cb4:	60a2      	str	r2, [r4, #8]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001cb6:	60e0      	str	r0, [r4, #12]
  tp->realprio  = prio;
 8001cb8:	63e2      	str	r2, [r4, #60]	; 0x3c
  tp->state     = CH_STATE_WTSTART;
 8001cba:	8425      	strh	r5, [r4, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001cbc:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  list_init(&tp->waiting);
 8001cc0:	f104 0228 	add.w	r2, r4, #40	; 0x28
  queue_init(&tp->msgqueue);
 8001cc4:	f104 032c 	add.w	r3, r4, #44	; 0x2c
  tp->mtxlist   = NULL;
 8001cc8:	2500      	movs	r5, #0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001cca:	4f0c      	ldr	r7, [pc, #48]	; (8001cfc <chThdCreateStatic+0x6c>)
  tp->name      = name;
 8001ccc:	480c      	ldr	r0, [pc, #48]	; (8001d00 <chThdCreateStatic+0x70>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001cce:	f844 7c04 	str.w	r7, [r4, #-4]
  REG_INSERT(tp);
 8001cd2:	e9c4 6104 	strd	r6, r1, [r4, #16]
  tp->name      = name;
 8001cd6:	61a0      	str	r0, [r4, #24]
  tp->epending  = (eventmask_t)0;
 8001cd8:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8001cdc:	4620      	mov	r0, r4
  REG_INSERT(tp);
 8001cde:	610c      	str	r4, [r1, #16]
  tqp->next = (thread_t *)tqp;
 8001ce0:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
 8001ce4:	6323      	str	r3, [r4, #48]	; 0x30
  chSchWakeupS(tp, MSG_OK);
 8001ce6:	4629      	mov	r1, r5
  REG_INSERT(tp);
 8001ce8:	6174      	str	r4, [r6, #20]
  chSchWakeupS(tp, MSG_OK);
 8001cea:	f7ff fee9 	bl	8001ac0 <chSchWakeupS>
 8001cee:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8001cf2:	4620      	mov	r0, r4
 8001cf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001cf6:	bf00      	nop
 8001cf8:	20000980 	.word	0x20000980
 8001cfc:	080002e1 	.word	0x080002e1
 8001d00:	08003320 	.word	0x08003320
	...

08001d10 <chThdRelease>:
 8001d10:	2320      	movs	r3, #32
 8001d12:	f383 8811 	msr	BASEPRI, r3
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8001d16:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 8001d1a:	3b01      	subs	r3, #1
 8001d1c:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8001d20:	6a03      	ldr	r3, [r0, #32]
 8001d22:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8001d26:	2b0f      	cmp	r3, #15
 8001d28:	d003      	beq.n	8001d32 <chThdRelease+0x22>
 8001d2a:	2300      	movs	r3, #0
 8001d2c:	f383 8811 	msr	BASEPRI, r3
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8001d30:	4770      	bx	lr
    REG_REMOVE(tp);
 8001d32:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
 8001d36:	611a      	str	r2, [r3, #16]
 8001d38:	6901      	ldr	r1, [r0, #16]
 8001d3a:	2200      	movs	r2, #0
 8001d3c:	614b      	str	r3, [r1, #20]
 8001d3e:	f382 8811 	msr	BASEPRI, r2
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8001d42:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8001d46:	f003 0303 	and.w	r3, r3, #3
 8001d4a:	2b01      	cmp	r3, #1
 8001d4c:	d006      	beq.n	8001d5c <chThdRelease+0x4c>
 8001d4e:	2b02      	cmp	r3, #2
 8001d50:	d103      	bne.n	8001d5a <chThdRelease+0x4a>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8001d52:	69c1      	ldr	r1, [r0, #28]
 8001d54:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8001d56:	f000 bae3 	b.w	8002320 <chPoolFree>
 8001d5a:	4770      	bx	lr
      chHeapFree(chThdGetWorkingAreaX(tp));
 8001d5c:	69c0      	ldr	r0, [r0, #28]
 8001d5e:	f000 ba4f 	b.w	8002200 <chHeapFree>
 8001d62:	bf00      	nop
	...

08001d70 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001d70:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8001d72:	4b10      	ldr	r3, [pc, #64]	; (8001db4 <chThdExitS+0x44>)
 8001d74:	699c      	ldr	r4, [r3, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 8001d76:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8001d78:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001d7a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8001d7e:	42ab      	cmp	r3, r5
 8001d80:	d007      	beq.n	8001d92 <chThdExitS+0x22>
  tlp->next = tp->queue.next;
 8001d82:	681a      	ldr	r2, [r3, #0]
 8001d84:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8001d86:	4618      	mov	r0, r3
 8001d88:	f7ff fe42 	bl	8001a10 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8001d8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8001d8e:	42ab      	cmp	r3, r5
 8001d90:	d1f7      	bne.n	8001d82 <chThdExitS+0x12>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8001d92:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001d96:	b943      	cbnz	r3, 8001daa <chThdExitS+0x3a>
 8001d98:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8001d9c:	079b      	lsls	r3, r3, #30
 8001d9e:	d104      	bne.n	8001daa <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8001da0:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 8001da4:	611a      	str	r2, [r3, #16]
 8001da6:	6922      	ldr	r2, [r4, #16]
 8001da8:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001daa:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001dac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8001db0:	f7ff be46 	b.w	8001a40 <chSchGoSleepS>
 8001db4:	20000980 	.word	0x20000980
	...

08001dc0 <chThdExit>:
 8001dc0:	2320      	movs	r3, #32
 8001dc2:	f383 8811 	msr	BASEPRI, r3
  chThdExitS(msg);
 8001dc6:	f7ff bfd3 	b.w	8001d70 <chThdExitS>
 8001dca:	bf00      	nop
 8001dcc:	0000      	movs	r0, r0
	...

08001dd0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8001dd0:	b508      	push	{r3, lr}
 8001dd2:	4601      	mov	r1, r0
 8001dd4:	2320      	movs	r3, #32
 8001dd6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001dda:	2008      	movs	r0, #8
 8001ddc:	f7ff fe48 	bl	8001a70 <chSchGoSleepTimeoutS>
 8001de0:	2300      	movs	r3, #0
 8001de2:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8001de6:	bd08      	pop	{r3, pc}
	...

08001df0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8001df0:	b161      	cbz	r1, 8001e0c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001df2:	4b08      	ldr	r3, [pc, #32]	; (8001e14 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8001df4:	b410      	push	{r4}
 8001df6:	4602      	mov	r2, r0
  tp->queue.prev             = tqp->prev;
 8001df8:	6844      	ldr	r4, [r0, #4]
  queue_insert(currp, tqp);
 8001dfa:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001dfc:	2004      	movs	r0, #4
 8001dfe:	e9c3 2400 	strd	r2, r4, [r3]
  tp->queue.prev->queue.next = tp;
 8001e02:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8001e04:	6053      	str	r3, [r2, #4]
}
 8001e06:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001e08:	f7ff be32 	b.w	8001a70 <chSchGoSleepTimeoutS>
}
 8001e0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001e10:	4770      	bx	lr
 8001e12:	bf00      	nop
 8001e14:	20000980 	.word	0x20000980
	...

08001e20 <chThdDequeueNextI>:
  return (bool)(tqp->next != (const thread_t *)tqp);
 8001e20:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8001e22:	4290      	cmp	r0, r2
 8001e24:	d009      	beq.n	8001e3a <chThdDequeueNextI+0x1a>
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001e26:	b410      	push	{r4}
  tqp->next             = tp->queue.next;
 8001e28:	6814      	ldr	r4, [r2, #0]
 8001e2a:	6004      	str	r4, [r0, #0]
 8001e2c:	4603      	mov	r3, r0
  tqp->next->queue.prev = (thread_t *)tqp;
 8001e2e:	6063      	str	r3, [r4, #4]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  (void) chSchReadyI(tp);
 8001e30:	4610      	mov	r0, r2
  tp->u.rdymsg = msg;
 8001e32:	6251      	str	r1, [r2, #36]	; 0x24
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001e34:	bc10      	pop	{r4}
  (void) chSchReadyI(tp);
 8001e36:	f7ff bdeb 	b.w	8001a10 <chSchReadyI>
 8001e3a:	4770      	bx	lr
 8001e3c:	0000      	movs	r0, r0
	...

08001e40 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001e40:	4b01      	ldr	r3, [pc, #4]	; (8001e48 <chTMStartMeasurementX+0x8>)
 8001e42:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001e44:	6083      	str	r3, [r0, #8]
}
 8001e46:	4770      	bx	lr
 8001e48:	e0001000 	.word	0xe0001000
 8001e4c:	00000000 	.word	0x00000000

08001e50 <chTMStopMeasurementX>:
 8001e50:	4b0e      	ldr	r3, [pc, #56]	; (8001e8c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001e52:	4a0f      	ldr	r2, [pc, #60]	; (8001e90 <chTMStopMeasurementX+0x40>)
 8001e54:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 8001e56:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001e58:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 8001e5a:	6884      	ldr	r4, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001e5c:	6f56      	ldr	r6, [r2, #116]	; 0x74
  if (tmp->last > tmp->worst) {
 8001e5e:	6842      	ldr	r2, [r0, #4]
  tmp->last = (now - tmp->last) - offset;
 8001e60:	1b1b      	subs	r3, r3, r4
  tmp->cumulative += (rttime_t)tmp->last;
 8001e62:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8001e66:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 8001e68:	18e6      	adds	r6, r4, r3
 8001e6a:	f145 0700 	adc.w	r7, r5, #0
  if (tmp->last > tmp->worst) {
 8001e6e:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8001e70:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8001e72:	bf88      	it	hi
 8001e74:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8001e76:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 8001e78:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 8001e7a:	e9c0 6704 	strd	r6, r7, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8001e7e:	e9c0 3102 	strd	r3, r1, [r0, #8]
    tmp->best = tmp->last;
 8001e82:	bf38      	it	cc
 8001e84:	6003      	strcc	r3, [r0, #0]
}
 8001e86:	bcf0      	pop	{r4, r5, r6, r7}
 8001e88:	4770      	bx	lr
 8001e8a:	bf00      	nop
 8001e8c:	e0001000 	.word	0xe0001000
 8001e90:	20000980 	.word	0x20000980
	...

08001ea0 <_tm_init>:
void _tm_init(void) {
 8001ea0:	b510      	push	{r4, lr}
  ch.tm.offset = (rtcnt_t)0;
 8001ea2:	4c0c      	ldr	r4, [pc, #48]	; (8001ed4 <_tm_init+0x34>)
void _tm_init(void) {
 8001ea4:	b086      	sub	sp, #24
  ch.tm.offset = (rtcnt_t)0;
 8001ea6:	2300      	movs	r3, #0
  tmp->best       = (rtcnt_t)-1;
 8001ea8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  tmp->cumulative = (rttime_t)0;
 8001eac:	2200      	movs	r2, #0
  chTMStartMeasurementX(&tm);
 8001eae:	4668      	mov	r0, sp
  ch.tm.offset = (rtcnt_t)0;
 8001eb0:	6763      	str	r3, [r4, #116]	; 0x74
  tmp->last       = (rtcnt_t)0;
 8001eb2:	e9cd 3301 	strd	r3, r3, [sp, #4]
  tmp->n          = (ucnt_t)0;
 8001eb6:	9303      	str	r3, [sp, #12]
  tmp->cumulative = (rttime_t)0;
 8001eb8:	2300      	movs	r3, #0
 8001eba:	e9cd 2304 	strd	r2, r3, [sp, #16]
  tmp->best       = (rtcnt_t)-1;
 8001ebe:	9100      	str	r1, [sp, #0]
  chTMStartMeasurementX(&tm);
 8001ec0:	f7ff ffbe 	bl	8001e40 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8001ec4:	4668      	mov	r0, sp
 8001ec6:	f7ff ffc3 	bl	8001e50 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001eca:	9b02      	ldr	r3, [sp, #8]
 8001ecc:	6763      	str	r3, [r4, #116]	; 0x74
}
 8001ece:	b006      	add	sp, #24
 8001ed0:	bd10      	pop	{r4, pc}
 8001ed2:	bf00      	nop
 8001ed4:	20000980 	.word	0x20000980
	...

08001ee0 <chRegFirstThread>:
 8001ee0:	2320      	movs	r3, #32
 8001ee2:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8001ee6:	4b05      	ldr	r3, [pc, #20]	; (8001efc <chRegFirstThread+0x1c>)
 8001ee8:	6918      	ldr	r0, [r3, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8001eea:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 8001eee:	3301      	adds	r3, #1
 8001ef0:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
 8001ef4:	2300      	movs	r3, #0
 8001ef6:	f383 8811 	msr	BASEPRI, r3
#endif
  chSysUnlock();

  return tp;
}
 8001efa:	4770      	bx	lr
 8001efc:	20000980 	.word	0x20000980

08001f00 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001f00:	b510      	push	{r4, lr}
 8001f02:	2320      	movs	r3, #32
 8001f04:	f383 8811 	msr	BASEPRI, r3
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001f08:	4b08      	ldr	r3, [pc, #32]	; (8001f2c <chRegNextThread+0x2c>)
  ntp = tp->newer;
 8001f0a:	6904      	ldr	r4, [r0, #16]
  if (ntp == (thread_t *)&ch.rlist) {
 8001f0c:	429c      	cmp	r4, r3
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
 8001f0e:	bf1d      	ittte	ne
 8001f10:	f894 3022 	ldrbne.w	r3, [r4, #34]	; 0x22
 8001f14:	3301      	addne	r3, #1
 8001f16:	f884 3022 	strbne.w	r3, [r4, #34]	; 0x22
    ntp = NULL;
 8001f1a:	2400      	moveq	r4, #0
 8001f1c:	2300      	movs	r3, #0
 8001f1e:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8001f22:	f7ff fef5 	bl	8001d10 <chThdRelease>
#endif

  return ntp;
}
 8001f26:	4620      	mov	r0, r4
 8001f28:	bd10      	pop	{r4, pc}
 8001f2a:	bf00      	nop
 8001f2c:	20000980 	.word	0x20000980

08001f30 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001f30:	2300      	movs	r3, #0
  tqp->prev = (thread_t *)tqp;
 8001f32:	e9c0 0000 	strd	r0, r0, [r0]
 8001f36:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8001f38:	4770      	bx	lr
 8001f3a:	bf00      	nop
 8001f3c:	0000      	movs	r0, r0
	...

08001f40 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8001f42:	4a37      	ldr	r2, [pc, #220]	; (8002020 <chMtxLockS+0xe0>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8001f44:	6883      	ldr	r3, [r0, #8]
  thread_t *ctp = currp;
 8001f46:	6995      	ldr	r5, [r2, #24]
  if (mp->owner != NULL) {
 8001f48:	2b00      	cmp	r3, #0
 8001f4a:	d040      	beq.n	8001fce <chMtxLockS+0x8e>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8001f4c:	68a9      	ldr	r1, [r5, #8]
 8001f4e:	689a      	ldr	r2, [r3, #8]
 8001f50:	4291      	cmp	r1, r2
 8001f52:	4604      	mov	r4, r0
 8001f54:	d907      	bls.n	8001f66 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001f56:	f893 2020 	ldrb.w	r2, [r3, #32]
        tp->prio = ctp->prio;
 8001f5a:	6099      	str	r1, [r3, #8]
        switch (tp->state) {
 8001f5c:	2a06      	cmp	r2, #6
 8001f5e:	d03b      	beq.n	8001fd8 <chMtxLockS+0x98>
 8001f60:	2a07      	cmp	r2, #7
 8001f62:	d015      	beq.n	8001f90 <chMtxLockS+0x50>
 8001f64:	b342      	cbz	r2, 8001fb8 <chMtxLockS+0x78>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8001f66:	4626      	mov	r6, r4
 8001f68:	4623      	mov	r3, r4
 8001f6a:	e003      	b.n	8001f74 <chMtxLockS+0x34>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001f6c:	6899      	ldr	r1, [r3, #8]
 8001f6e:	68aa      	ldr	r2, [r5, #8]
 8001f70:	4291      	cmp	r1, r2
 8001f72:	d32a      	bcc.n	8001fca <chMtxLockS+0x8a>
    cp = cp->queue.next;
 8001f74:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001f76:	429c      	cmp	r4, r3
 8001f78:	d1f8      	bne.n	8001f6c <chMtxLockS+0x2c>
  tp->queue.prev             = cp->queue.prev;
 8001f7a:	6873      	ldr	r3, [r6, #4]
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001f7c:	2006      	movs	r0, #6
 8001f7e:	e9c5 6300 	strd	r6, r3, [r5]
  tp->queue.prev->queue.next = tp;
 8001f82:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
 8001f84:	6075      	str	r5, [r6, #4]
      ctp->u.wtmtxp = mp;
 8001f86:	626c      	str	r4, [r5, #36]	; 0x24
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 8001f88:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
 8001f8c:	f7ff bd58 	b.w	8001a40 <chSchGoSleepS>
  tp->queue.prev->queue.next = tp->queue.next;
 8001f90:	e9d3 0200 	ldrd	r0, r2, [r3]
 8001f94:	6010      	str	r0, [r2, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001f96:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8001f98:	6818      	ldr	r0, [r3, #0]
 8001f9a:	6042      	str	r2, [r0, #4]
 8001f9c:	4632      	mov	r2, r6
 8001f9e:	e002      	b.n	8001fa6 <chMtxLockS+0x66>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001fa0:	6890      	ldr	r0, [r2, #8]
 8001fa2:	4288      	cmp	r0, r1
 8001fa4:	d332      	bcc.n	800200c <chMtxLockS+0xcc>
    cp = cp->queue.next;
 8001fa6:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001fa8:	4296      	cmp	r6, r2
 8001faa:	d1f9      	bne.n	8001fa0 <chMtxLockS+0x60>
  tp->queue.prev             = cp->queue.prev;
 8001fac:	6872      	ldr	r2, [r6, #4]
 8001fae:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8001fb2:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8001fb4:	6073      	str	r3, [r6, #4]
 8001fb6:	e7d6      	b.n	8001f66 <chMtxLockS+0x26>
  tp->queue.prev->queue.next = tp->queue.next;
 8001fb8:	e9d3 1200 	ldrd	r1, r2, [r3]
 8001fbc:	6011      	str	r1, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001fbe:	6819      	ldr	r1, [r3, #0]
          (void) chSchReadyI(queue_dequeue(tp));
 8001fc0:	4618      	mov	r0, r3
 8001fc2:	604a      	str	r2, [r1, #4]
 8001fc4:	f7ff fd24 	bl	8001a10 <chSchReadyI>
          break;
 8001fc8:	e7cd      	b.n	8001f66 <chMtxLockS+0x26>
    cp = cp->queue.next;
 8001fca:	461e      	mov	r6, r3
 8001fcc:	e7d5      	b.n	8001f7a <chMtxLockS+0x3a>
    mp->next = ctp->mtxlist;
 8001fce:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8001fd0:	e9c0 5302 	strd	r5, r3, [r0, #8]
    ctp->mtxlist = mp;
 8001fd4:	63a8      	str	r0, [r5, #56]	; 0x38
}
 8001fd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tp->queue.prev->queue.next = tp->queue.next;
 8001fd8:	e9d3 0200 	ldrd	r0, r2, [r3]
 8001fdc:	6010      	str	r0, [r2, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001fde:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8001fe0:	6818      	ldr	r0, [r3, #0]
 8001fe2:	4637      	mov	r7, r6
 8001fe4:	6042      	str	r2, [r0, #4]
 8001fe6:	4632      	mov	r2, r6
 8001fe8:	e002      	b.n	8001ff0 <chMtxLockS+0xb0>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001fea:	6890      	ldr	r0, [r2, #8]
 8001fec:	4288      	cmp	r0, r1
 8001fee:	d314      	bcc.n	800201a <chMtxLockS+0xda>
    cp = cp->queue.next;
 8001ff0:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001ff2:	4296      	cmp	r6, r2
 8001ff4:	d1f9      	bne.n	8001fea <chMtxLockS+0xaa>
  tp->queue.prev             = cp->queue.prev;
 8001ff6:	687a      	ldr	r2, [r7, #4]
      while (tp->prio < ctp->prio) {
 8001ff8:	68a9      	ldr	r1, [r5, #8]
 8001ffa:	e9c3 7200 	strd	r7, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8001ffe:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8002000:	607b      	str	r3, [r7, #4]
          tp = tp->u.wtmtxp->owner;
 8002002:	68b3      	ldr	r3, [r6, #8]
      while (tp->prio < ctp->prio) {
 8002004:	689a      	ldr	r2, [r3, #8]
 8002006:	428a      	cmp	r2, r1
 8002008:	d3a5      	bcc.n	8001f56 <chMtxLockS+0x16>
 800200a:	e7ac      	b.n	8001f66 <chMtxLockS+0x26>
    cp = cp->queue.next;
 800200c:	4616      	mov	r6, r2
  tp->queue.prev             = cp->queue.prev;
 800200e:	6872      	ldr	r2, [r6, #4]
 8002010:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8002014:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8002016:	6073      	str	r3, [r6, #4]
 8002018:	e7a5      	b.n	8001f66 <chMtxLockS+0x26>
    cp = cp->queue.next;
 800201a:	4617      	mov	r7, r2
 800201c:	e7eb      	b.n	8001ff6 <chMtxLockS+0xb6>
 800201e:	bf00      	nop
 8002020:	20000980 	.word	0x20000980
	...

08002030 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 8002030:	b508      	push	{r3, lr}
 8002032:	2320      	movs	r3, #32
 8002034:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 8002038:	f7ff ff82 	bl	8001f40 <chMtxLockS>
 800203c:	2300      	movs	r3, #0
 800203e:	f383 8811 	msr	BASEPRI, r3
}
 8002042:	bd08      	pop	{r3, pc}
	...

08002050 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8002050:	4b17      	ldr	r3, [pc, #92]	; (80020b0 <chMtxUnlock+0x60>)
void chMtxUnlock(mutex_t *mp) {
 8002052:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002054:	699d      	ldr	r5, [r3, #24]
 8002056:	2320      	movs	r3, #32
 8002058:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 800205c:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800205e:	68c3      	ldr	r3, [r0, #12]
 8002060:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002062:	4284      	cmp	r4, r0
 8002064:	d01d      	beq.n	80020a2 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8002066:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8002068:	b14b      	cbz	r3, 800207e <chMtxUnlock+0x2e>
 800206a:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800206c:	4293      	cmp	r3, r2
 800206e:	d003      	beq.n	8002078 <chMtxUnlock+0x28>
 8002070:	6892      	ldr	r2, [r2, #8]
 8002072:	4291      	cmp	r1, r2
 8002074:	bf38      	it	cc
 8002076:	4611      	movcc	r1, r2
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8002078:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 800207a:	2b00      	cmp	r3, #0
 800207c:	d1f5      	bne.n	800206a <chMtxUnlock+0x1a>
 800207e:	4603      	mov	r3, r0
  tqp->next             = tp->queue.next;
 8002080:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8002082:	6ba6      	ldr	r6, [r4, #56]	; 0x38
      ctp->prio = newprio;
 8002084:	60a9      	str	r1, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002086:	4620      	mov	r0, r4
 8002088:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800208a:	6053      	str	r3, [r2, #4]
      mp->next = tp->mtxlist;
 800208c:	e9c3 4602 	strd	r4, r6, [r3, #8]
      tp->mtxlist = mp;
 8002090:	63a3      	str	r3, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 8002092:	f7ff fcbd 	bl	8001a10 <chSchReadyI>
      chSchRescheduleS();
 8002096:	f7ff fd73 	bl	8001b80 <chSchRescheduleS>
 800209a:	2300      	movs	r3, #0
 800209c:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 80020a0:	bd70      	pop	{r4, r5, r6, pc}
      mp->owner = NULL;
 80020a2:	2300      	movs	r3, #0
 80020a4:	60a3      	str	r3, [r4, #8]
 80020a6:	2300      	movs	r3, #0
 80020a8:	f383 8811 	msr	BASEPRI, r3
}
 80020ac:	bd70      	pop	{r4, r5, r6, pc}
 80020ae:	bf00      	nop
 80020b0:	20000980 	.word	0x20000980
	...

080020c0 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 80020c0:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 80020c2:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 80020c6:	4319      	orrs	r1, r3
  if (((tp->state == CH_STATE_WTOREVT) &&
 80020c8:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80020ca:	6341      	str	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 80020cc:	d009      	beq.n	80020e2 <chEvtSignalI+0x22>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80020ce:	2a0b      	cmp	r2, #11
 80020d0:	d000      	beq.n	80020d4 <chEvtSignalI+0x14>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 80020d2:	4770      	bx	lr
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80020d4:	6a43      	ldr	r3, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 80020d6:	438b      	bics	r3, r1
 80020d8:	d1fb      	bne.n	80020d2 <chEvtSignalI+0x12>
    tp->u.rdymsg = MSG_OK;
 80020da:	2300      	movs	r3, #0
 80020dc:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80020de:	f7ff bc97 	b.w	8001a10 <chSchReadyI>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80020e2:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 80020e4:	4219      	tst	r1, r3
 80020e6:	d1f8      	bne.n	80020da <chEvtSignalI+0x1a>
 80020e8:	4770      	bx	lr
 80020ea:	bf00      	nop
 80020ec:	0000      	movs	r0, r0
	...

080020f0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80020f0:	b570      	push	{r4, r5, r6, lr}
  elp = esp->next;
 80020f2:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 80020f4:	42a0      	cmp	r0, r4
 80020f6:	d00f      	beq.n	8002118 <chEvtBroadcastFlagsI+0x28>
 80020f8:	4606      	mov	r6, r0
 80020fa:	460d      	mov	r5, r1
    elp->flags |= flags;
 80020fc:	68e3      	ldr	r3, [r4, #12]
 80020fe:	432b      	orrs	r3, r5
 8002100:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 8002102:	b115      	cbz	r5, 800210a <chEvtBroadcastFlagsI+0x1a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8002104:	6922      	ldr	r2, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 8002106:	4213      	tst	r3, r2
 8002108:	d003      	beq.n	8002112 <chEvtBroadcastFlagsI+0x22>
      chEvtSignalI(elp->listener, elp->events);
 800210a:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 800210e:	f7ff ffd7 	bl	80020c0 <chEvtSignalI>
    elp = elp->next;
 8002112:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 8002114:	42a6      	cmp	r6, r4
 8002116:	d1f1      	bne.n	80020fc <chEvtBroadcastFlagsI+0xc>
}
 8002118:	bd70      	pop	{r4, r5, r6, pc}
 800211a:	bf00      	nop
 800211c:	0000      	movs	r0, r0
	...

08002120 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8002120:	4b02      	ldr	r3, [pc, #8]	; (800212c <_core_init+0xc>)
 8002122:	4903      	ldr	r1, [pc, #12]	; (8002130 <_core_init+0x10>)
  ch_memcore.endmem  = __heap_end__;
 8002124:	4a03      	ldr	r2, [pc, #12]	; (8002134 <_core_init+0x14>)
 8002126:	e9c3 1200 	strd	r1, r2, [r3]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 800212a:	4770      	bx	lr
 800212c:	200009f8 	.word	0x200009f8
 8002130:	200012f0 	.word	0x200012f0
 8002134:	20020000 	.word	0x20020000
	...

08002140 <chCoreAllocAlignedWithOffsetI>:
 *
 * @iclass
 */
void *chCoreAllocAlignedWithOffsetI(size_t size,
                                    unsigned align,
                                    size_t offset) {
 8002140:	b470      	push	{r4, r5, r6}

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002142:	4d0b      	ldr	r5, [pc, #44]	; (8002170 <chCoreAllocAlignedWithOffsetI+0x30>)
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8002144:	e9d5 6400 	ldrd	r6, r4, [r5]
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002148:	4432      	add	r2, r6
  size = MEM_ALIGN_NEXT(size, align);
 800214a:	3801      	subs	r0, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800214c:	3a01      	subs	r2, #1
  size = MEM_ALIGN_NEXT(size, align);
 800214e:	1843      	adds	r3, r0, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002150:	1850      	adds	r0, r2, r1
  size = MEM_ALIGN_NEXT(size, align);
 8002152:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002154:	4008      	ands	r0, r1
  size = MEM_ALIGN_NEXT(size, align);
 8002156:	4019      	ands	r1, r3
  next = p + size;
 8002158:	4401      	add	r1, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800215a:	428c      	cmp	r4, r1
 800215c:	d304      	bcc.n	8002168 <chCoreAllocAlignedWithOffsetI+0x28>
 800215e:	428e      	cmp	r6, r1
 8002160:	d802      	bhi.n	8002168 <chCoreAllocAlignedWithOffsetI+0x28>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8002162:	6029      	str	r1, [r5, #0]

  return p;
}
 8002164:	bc70      	pop	{r4, r5, r6}
 8002166:	4770      	bx	lr
    return NULL;
 8002168:	2000      	movs	r0, #0
}
 800216a:	bc70      	pop	{r4, r5, r6}
 800216c:	4770      	bx	lr
 800216e:	bf00      	nop
 8002170:	200009f8 	.word	0x200009f8
	...

08002180 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8002180:	b4f0      	push	{r4, r5, r6, r7}
 8002182:	2320      	movs	r3, #32
 8002184:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002188:	4d0d      	ldr	r5, [pc, #52]	; (80021c0 <chCoreAllocAlignedWithOffset+0x40>)
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800218a:	e9d5 7400 	ldrd	r7, r4, [r5]
 800218e:	1e4e      	subs	r6, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002190:	443a      	add	r2, r7
  size = MEM_ALIGN_NEXT(size, align);
 8002192:	1983      	adds	r3, r0, r6
 8002194:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002196:	1990      	adds	r0, r2, r6
  size = MEM_ALIGN_NEXT(size, align);
 8002198:	400b      	ands	r3, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800219a:	4008      	ands	r0, r1
  next = p + size;
 800219c:	4403      	add	r3, r0
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800219e:	42a3      	cmp	r3, r4
 80021a0:	d807      	bhi.n	80021b2 <chCoreAllocAlignedWithOffset+0x32>
 80021a2:	429f      	cmp	r7, r3
 80021a4:	d805      	bhi.n	80021b2 <chCoreAllocAlignedWithOffset+0x32>
  ch_memcore.nextmem = next;
 80021a6:	602b      	str	r3, [r5, #0]
 80021a8:	2300      	movs	r3, #0
 80021aa:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 80021ae:	bcf0      	pop	{r4, r5, r6, r7}
 80021b0:	4770      	bx	lr
    return NULL;
 80021b2:	2000      	movs	r0, #0
 80021b4:	2300      	movs	r3, #0
 80021b6:	f383 8811 	msr	BASEPRI, r3
}
 80021ba:	bcf0      	pop	{r4, r5, r6, r7}
 80021bc:	4770      	bx	lr
 80021be:	bf00      	nop
 80021c0:	200009f8 	.word	0x200009f8
	...

080021d0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(ch_memcore.endmem - ch_memcore.nextmem);
 80021d0:	4b02      	ldr	r3, [pc, #8]	; (80021dc <chCoreGetStatusX+0xc>)
 80021d2:	e9d3 3000 	ldrd	r3, r0, [r3]
  /*lint -restore*/
}
 80021d6:	1ac0      	subs	r0, r0, r3
 80021d8:	4770      	bx	lr
 80021da:	bf00      	nop
 80021dc:	200009f8 	.word	0x200009f8

080021e0 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80021e0:	4b04      	ldr	r3, [pc, #16]	; (80021f4 <_heap_init+0x14>)
 80021e2:	4a05      	ldr	r2, [pc, #20]	; (80021f8 <_heap_init+0x18>)
 80021e4:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 80021e6:	f103 000c 	add.w	r0, r3, #12
  H_NEXT(&default_heap.header) = NULL;
 80021ea:	2200      	movs	r2, #0
  H_PAGES(&default_heap.header) = 0;
 80021ec:	e9c3 2201 	strd	r2, r2, [r3, #4]
  chMtxObjectInit(&default_heap.mtx);
 80021f0:	f7ff be9e 	b.w	8001f30 <chMtxObjectInit>
 80021f4:	20000a00 	.word	0x20000a00
 80021f8:	08002181 	.word	0x08002181
 80021fc:	00000000 	.word	0x00000000

08002200 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002202:	e950 5302 	ldrd	r5, r3, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002206:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002208:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800220a:	f105 070c 	add.w	r7, r5, #12
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800220e:	f840 3c04 	str.w	r3, [r0, #-4]
void chHeapFree(void *p) {
 8002212:	4606      	mov	r6, r0
  hp = (heap_header_t *)p - 1U;
 8002214:	f1a0 0408 	sub.w	r4, r0, #8
  qp = &heapp->header;
 8002218:	3504      	adds	r5, #4
  H_LOCK(heapp);
 800221a:	4638      	mov	r0, r7
 800221c:	f7ff ff08 	bl	8002030 <chMtxLock>
  qp = &heapp->header;
 8002220:	462b      	mov	r3, r5

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8002222:	42ab      	cmp	r3, r5
 8002224:	681a      	ldr	r2, [r3, #0]
 8002226:	d001      	beq.n	800222c <chHeapFree+0x2c>
 8002228:	429c      	cmp	r4, r3
 800222a:	d902      	bls.n	8002232 <chHeapFree+0x32>
 800222c:	b11a      	cbz	r2, 8002236 <chHeapFree+0x36>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800222e:	4294      	cmp	r4, r2
 8002230:	d301      	bcc.n	8002236 <chHeapFree+0x36>
void chHeapFree(void *p) {
 8002232:	4613      	mov	r3, r2
 8002234:	e7f5      	b.n	8002222 <chHeapFree+0x22>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002236:	f856 1c04 	ldr.w	r1, [r6, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 800223a:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 800223e:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002240:	1c4a      	adds	r2, r1, #1
 8002242:	f856 0c08 	ldr.w	r0, [r6, #-8]
 8002246:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
 800224a:	4281      	cmp	r1, r0
 800224c:	d00a      	beq.n	8002264 <chHeapFree+0x64>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 800224e:	6859      	ldr	r1, [r3, #4]
 8002250:	1c4a      	adds	r2, r1, #1
 8002252:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8002256:	4294      	cmp	r4, r2
 8002258:	d012      	beq.n	8002280 <chHeapFree+0x80>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800225a:	4638      	mov	r0, r7

  return;
}
 800225c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
 8002260:	f7ff bef6 	b.w	8002050 <chMtxUnlock>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002264:	6849      	ldr	r1, [r1, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002266:	f854 0032 	ldr.w	r0, [r4, r2, lsl #3]
 800226a:	f846 0c08 	str.w	r0, [r6, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800226e:	440a      	add	r2, r1
 8002270:	f846 2c04 	str.w	r2, [r6, #-4]
      if ((H_LIMIT(qp) == hp)) {
 8002274:	6859      	ldr	r1, [r3, #4]
 8002276:	1c4a      	adds	r2, r1, #1
 8002278:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 800227c:	4294      	cmp	r4, r2
 800227e:	d1ec      	bne.n	800225a <chHeapFree+0x5a>
        H_NEXT(qp) = H_NEXT(hp);
 8002280:	e956 0202 	ldrd	r0, r2, [r6, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002284:	3201      	adds	r2, #1
 8002286:	4411      	add	r1, r2
        H_NEXT(qp) = H_NEXT(hp);
 8002288:	6018      	str	r0, [r3, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800228a:	6059      	str	r1, [r3, #4]
  H_UNLOCK(heapp);
 800228c:	4638      	mov	r0, r7
}
 800228e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
 8002292:	f7ff bedd 	b.w	8002050 <chMtxUnlock>
 8002296:	bf00      	nop
	...

080022a0 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80022a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 80022a4:	4c17      	ldr	r4, [pc, #92]	; (8002304 <chHeapStatus+0x64>)
 80022a6:	2800      	cmp	r0, #0
 80022a8:	bf18      	it	ne
 80022aa:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 80022ac:	f104 070c 	add.w	r7, r4, #12
 80022b0:	4638      	mov	r0, r7
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80022b2:	4689      	mov	r9, r1
 80022b4:	4690      	mov	r8, r2
  H_LOCK(heapp);
 80022b6:	f7ff febb 	bl	8002030 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80022ba:	6863      	ldr	r3, [r4, #4]
 80022bc:	b1f3      	cbz	r3, 80022fc <chHeapStatus+0x5c>
  lpages = 0U;
 80022be:	2400      	movs	r4, #0
  tpages = 0U;
 80022c0:	4625      	mov	r5, r4
  n = 0U;
 80022c2:	4626      	mov	r6, r4
  while (H_NEXT(qp) != NULL) {
 80022c4:	e9d3 3000 	ldrd	r3, r0, [r3]
 80022c8:	4284      	cmp	r4, r0
    size_t pages = H_PAGES(H_NEXT(qp));

    /* Updating counters.*/
    n++;
 80022ca:	f106 0601 	add.w	r6, r6, #1
    tpages += pages;
 80022ce:	4405      	add	r5, r0
 80022d0:	bf38      	it	cc
 80022d2:	4604      	movcc	r4, r0
  while (H_NEXT(qp) != NULL) {
 80022d4:	2b00      	cmp	r3, #0
 80022d6:	d1f5      	bne.n	80022c4 <chHeapStatus+0x24>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 80022d8:	f1b9 0f00 	cmp.w	r9, #0
 80022dc:	d002      	beq.n	80022e4 <chHeapStatus+0x44>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 80022de:	00ed      	lsls	r5, r5, #3
 80022e0:	f8c9 5000 	str.w	r5, [r9]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 80022e4:	f1b8 0f00 	cmp.w	r8, #0
 80022e8:	d002      	beq.n	80022f0 <chHeapStatus+0x50>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 80022ea:	00e4      	lsls	r4, r4, #3
 80022ec:	f8c8 4000 	str.w	r4, [r8]
  }
  H_UNLOCK(heapp);
 80022f0:	4638      	mov	r0, r7
 80022f2:	f7ff fead 	bl	8002050 <chMtxUnlock>

  return n;
}
 80022f6:	4630      	mov	r0, r6
 80022f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  lpages = 0U;
 80022fc:	461c      	mov	r4, r3
  tpages = 0U;
 80022fe:	461d      	mov	r5, r3
  n = 0U;
 8002300:	461e      	mov	r6, r3
 8002302:	e7e9      	b.n	80022d8 <chHeapStatus+0x38>
 8002304:	20000a00 	.word	0x20000a00
	...

08002310 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8002310:	b410      	push	{r4}

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8002312:	2400      	movs	r4, #0
 8002314:	6004      	str	r4, [r0, #0]
  mp->object_size = size;
  mp->align = align;
 8002316:	e9c0 1201 	strd	r1, r2, [r0, #4]
  mp->provider = provider;
 800231a:	60c3      	str	r3, [r0, #12]
}
 800231c:	bc10      	pop	{r4}
 800231e:	4770      	bx	lr

08002320 <chPoolFree>:
 8002320:	2320      	movs	r3, #32
 8002322:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck((mp != NULL) && (objp != NULL));

  chDbgAssert(((size_t)objp & MEM_ALIGN_MASK(mp->align)) == 0U,
              "unaligned object");

  php->next = mp->next;
 8002326:	6803      	ldr	r3, [r0, #0]
 8002328:	600b      	str	r3, [r1, #0]
 800232a:	2300      	movs	r3, #0
  mp->next = php;
 800232c:	6001      	str	r1, [r0, #0]
 800232e:	f383 8811 	msr	BASEPRI, r3
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
  chSysUnlock();
}
 8002332:	4770      	bx	lr
	...

08002340 <chCoreAllocAlignedI>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8002340:	2200      	movs	r2, #0
 8002342:	f7ff befd 	b.w	8002140 <chCoreAllocAlignedWithOffsetI>
 8002346:	bf00      	nop
	...

08002350 <_factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void _factory_init(void) {
 8002350:	b570      	push	{r4, r5, r6, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8002352:	4c11      	ldr	r4, [pc, #68]	; (8002398 <_factory_init+0x48>)
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8002354:	4d11      	ldr	r5, [pc, #68]	; (800239c <_factory_init+0x4c>)
 8002356:	4620      	mov	r0, r4
 8002358:	f7ff fdea 	bl	8001f30 <chMtxObjectInit>
  dlp->next = (dyn_element_t *)dlp;
 800235c:	f104 0610 	add.w	r6, r4, #16
 8002360:	462b      	mov	r3, r5
 8002362:	f104 0014 	add.w	r0, r4, #20
 8002366:	2204      	movs	r2, #4
 8002368:	2114      	movs	r1, #20
 800236a:	6126      	str	r6, [r4, #16]
 800236c:	f7ff ffd0 	bl	8002310 <chPoolObjectInitAligned>
 8002370:	f104 0624 	add.w	r6, r4, #36	; 0x24
 8002374:	462b      	mov	r3, r5
 8002376:	2204      	movs	r2, #4
 8002378:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800237c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8002380:	211c      	movs	r1, #28
 8002382:	e9c4 6509 	strd	r6, r5, [r4, #36]	; 0x24
 8002386:	f7ff ffc3 	bl	8002310 <chPoolObjectInitAligned>
 800238a:	f104 023c 	add.w	r2, r4, #60	; 0x3c
 800238e:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8002392:	e9c4 230f 	strd	r2, r3, [r4, #60]	; 0x3c
  dyn_list_init(&ch_factory.mbx_list);
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
#endif
}
 8002396:	bd70      	pop	{r4, r5, r6, pc}
 8002398:	20000a1c 	.word	0x20000a1c
 800239c:	08002341 	.word	0x08002341

080023a0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80023a0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80023a4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80023a6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023aa:	2300      	movs	r3, #0
 80023ac:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80023b0:	4770      	bx	lr
 80023b2:	bf00      	nop
	...

080023c0 <_port_irq_epilogue>:
 80023c0:	2320      	movs	r3, #32
 80023c2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80023c6:	4b0f      	ldr	r3, [pc, #60]	; (8002404 <_port_irq_epilogue+0x44>)
 80023c8:	685b      	ldr	r3, [r3, #4]
 80023ca:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80023ce:	d102      	bne.n	80023d6 <_port_irq_epilogue+0x16>
 80023d0:	f383 8811 	msr	BASEPRI, r3
 80023d4:	4770      	bx	lr
void _port_irq_epilogue(void) {
 80023d6:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80023d8:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80023dc:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80023e0:	f844 3c04 	str.w	r3, [r4, #-4]
    ctxp--;
 80023e4:	f1a4 0320 	sub.w	r3, r4, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80023e8:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80023ec:	f7ff fb98 	bl	8001b20 <chSchIsPreemptionRequired>
 80023f0:	b118      	cbz	r0, 80023fa <_port_irq_epilogue+0x3a>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80023f2:	4b05      	ldr	r3, [pc, #20]	; (8002408 <_port_irq_epilogue+0x48>)
 80023f4:	f844 3c08 	str.w	r3, [r4, #-8]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 80023f8:	bd10      	pop	{r4, pc}
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80023fa:	4b04      	ldr	r3, [pc, #16]	; (800240c <_port_irq_epilogue+0x4c>)
 80023fc:	f844 3c08 	str.w	r3, [r4, #-8]
}
 8002400:	bd10      	pop	{r4, pc}
 8002402:	bf00      	nop
 8002404:	e000ed00 	.word	0xe000ed00
 8002408:	080002f1 	.word	0x080002f1
 800240c:	080002f4 	.word	0x080002f4

08002410 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8002410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002414:	4604      	mov	r4, r0
 8002416:	b087      	sub	sp, #28
 8002418:	460e      	mov	r6, r1
 800241a:	4690      	mov	r8, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800241c:	2700      	movs	r7, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800241e:	7831      	ldrb	r1, [r6, #0]
 8002420:	1c72      	adds	r2, r6, #1
    if (c == 0)
 8002422:	b159      	cbz	r1, 800243c <chvprintf+0x2c>
      return n;
    if (c != '%') {
 8002424:	2925      	cmp	r1, #37	; 0x25
 8002426:	d00d      	beq.n	8002444 <chvprintf+0x34>
      streamPut(chp, (uint8_t)c);
 8002428:	6823      	ldr	r3, [r4, #0]
    c = *fmt++;
 800242a:	4616      	mov	r6, r2
      streamPut(chp, (uint8_t)c);
 800242c:	68db      	ldr	r3, [r3, #12]
 800242e:	4620      	mov	r0, r4
 8002430:	4798      	blx	r3
    c = *fmt++;
 8002432:	7831      	ldrb	r1, [r6, #0]
      n++;
 8002434:	3701      	adds	r7, #1
    c = *fmt++;
 8002436:	1c72      	adds	r2, r6, #1
    if (c == 0)
 8002438:	2900      	cmp	r1, #0
 800243a:	d1f3      	bne.n	8002424 <chvprintf+0x14>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800243c:	4638      	mov	r0, r7
 800243e:	b007      	add	sp, #28
 8002440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (*fmt == '-') {
 8002444:	7871      	ldrb	r1, [r6, #1]
 8002446:	292d      	cmp	r1, #45	; 0x2d
 8002448:	bf03      	ittte	eq
 800244a:	78b1      	ldrbeq	r1, [r6, #2]
      fmt++;
 800244c:	1cb2      	addeq	r2, r6, #2
      left_align = TRUE;
 800244e:	f04f 0c01 	moveq.w	ip, #1
    left_align = FALSE;
 8002452:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '0') {
 8002456:	2930      	cmp	r1, #48	; 0x30
 8002458:	bf03      	ittte	eq
 800245a:	7851      	ldrbeq	r1, [r2, #1]
      fmt++;
 800245c:	3201      	addeq	r2, #1
      filler = '0';
 800245e:	f04f 0a30 	moveq.w	sl, #48	; 0x30
    filler = ' ';
 8002462:	f04f 0a20 	movne.w	sl, #32
 8002466:	3201      	adds	r2, #1
    width = 0;
 8002468:	2500      	movs	r5, #0
 800246a:	e007      	b.n	800247c <chvprintf+0x6c>
        c = va_arg(ap, int);
 800246c:	f898 3000 	ldrb.w	r3, [r8]
 8002470:	f108 0804 	add.w	r8, r8, #4
 8002474:	f812 1b01 	ldrb.w	r1, [r2], #1
      width = width * 10 + c;
 8002478:	eb03 0540 	add.w	r5, r3, r0, lsl #1
      if (c >= '0' && c <= '9')
 800247c:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8002480:	b2db      	uxtb	r3, r3
 8002482:	2b09      	cmp	r3, #9
      c = *fmt++;
 8002484:	4696      	mov	lr, r2
      width = width * 10 + c;
 8002486:	eb05 0085 	add.w	r0, r5, r5, lsl #2
      if (c >= '0' && c <= '9')
 800248a:	d9f3      	bls.n	8002474 <chvprintf+0x64>
      else if (c == '*')
 800248c:	292a      	cmp	r1, #42	; 0x2a
 800248e:	d0ed      	beq.n	800246c <chvprintf+0x5c>
    if (c == '.') {
 8002490:	292e      	cmp	r1, #46	; 0x2e
    precision = 0;
 8002492:	f04f 0200 	mov.w	r2, #0
    if (c == '.') {
 8002496:	d04a      	beq.n	800252e <chvprintf+0x11e>
    if (c == 'l' || c == 'L') {
 8002498:	f001 03df 	and.w	r3, r1, #223	; 0xdf
 800249c:	2b4c      	cmp	r3, #76	; 0x4c
 800249e:	f10e 0601 	add.w	r6, lr, #1
 80024a2:	d050      	beq.n	8002546 <chvprintf+0x136>
      is_long = (c >= 'A') && (c <= 'Z');
 80024a4:	f1a1 0341 	sub.w	r3, r1, #65	; 0x41
    switch (c) {
 80024a8:	f1a1 0044 	sub.w	r0, r1, #68	; 0x44
      is_long = (c >= 'A') && (c <= 'Z');
 80024ac:	b2db      	uxtb	r3, r3
    switch (c) {
 80024ae:	2834      	cmp	r0, #52	; 0x34
 80024b0:	f200 811a 	bhi.w	80026e8 <chvprintf+0x2d8>
 80024b4:	e8df f010 	tbh	[pc, r0, lsl #1]
 80024b8:	0118016a 	.word	0x0118016a
 80024bc:	01180118 	.word	0x01180118
 80024c0:	016a0118 	.word	0x016a0118
 80024c4:	01180118 	.word	0x01180118
 80024c8:	01180118 	.word	0x01180118
 80024cc:	01140118 	.word	0x01140118
 80024d0:	01180118 	.word	0x01180118
 80024d4:	01180118 	.word	0x01180118
 80024d8:	00e50118 	.word	0x00e50118
 80024dc:	01180118 	.word	0x01180118
 80024e0:	01180173 	.word	0x01180173
 80024e4:	01180118 	.word	0x01180118
 80024e8:	01180118 	.word	0x01180118
 80024ec:	01180118 	.word	0x01180118
 80024f0:	01180118 	.word	0x01180118
 80024f4:	00920118 	.word	0x00920118
 80024f8:	0118016a 	.word	0x0118016a
 80024fc:	01180118 	.word	0x01180118
 8002500:	016a0118 	.word	0x016a0118
 8002504:	01180118 	.word	0x01180118
 8002508:	01180118 	.word	0x01180118
 800250c:	01140118 	.word	0x01140118
 8002510:	01180118 	.word	0x01180118
 8002514:	006f0118 	.word	0x006f0118
 8002518:	00e50118 	.word	0x00e50118
 800251c:	01180118 	.word	0x01180118
 8002520:	0173      	.short	0x0173
          c = va_arg(ap, int);
 8002522:	f898 3000 	ldrb.w	r3, [r8]
 8002526:	f108 0804 	add.w	r8, r8, #4
        precision += c;
 800252a:	eb03 0240 	add.w	r2, r3, r0, lsl #1
        c = *fmt++;
 800252e:	f81e 1b01 	ldrb.w	r1, [lr], #1
        if (c >= '0' && c <= '9')
 8002532:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8002536:	b2db      	uxtb	r3, r3
 8002538:	2b09      	cmp	r3, #9
        precision *= 10;
 800253a:	eb02 0082 	add.w	r0, r2, r2, lsl #2
        if (c >= '0' && c <= '9')
 800253e:	d9f4      	bls.n	800252a <chvprintf+0x11a>
        else if (c == '*')
 8002540:	292a      	cmp	r1, #42	; 0x2a
 8002542:	d0ee      	beq.n	8002522 <chvprintf+0x112>
 8002544:	e7a8      	b.n	8002498 <chvprintf+0x88>
      if (*fmt)
 8002546:	f89e 3000 	ldrb.w	r3, [lr]
 800254a:	b30b      	cbz	r3, 8002590 <chvprintf+0x180>
    switch (c) {
 800254c:	f1a3 0144 	sub.w	r1, r3, #68	; 0x44
 8002550:	2934      	cmp	r1, #52	; 0x34
 8002552:	f200 80cb 	bhi.w	80026ec <chvprintf+0x2dc>
 8002556:	e8df f001 	tbb	[pc, r1]
 800255a:	c9d9      	.short	0xc9d9
 800255c:	d9c9c9c9 	.word	0xd9c9c9c9
 8002560:	c9c9c9c9 	.word	0xc9c9c9c9
 8002564:	c9c9c4c9 	.word	0xc9c9c4c9
 8002568:	95c9c9c9 	.word	0x95c9c9c9
 800256c:	c9d6c9c9 	.word	0xc9d6c9c9
 8002570:	c9c9c9c9 	.word	0xc9c9c9c9
 8002574:	c9c9c9c9 	.word	0xc9c9c9c9
 8002578:	c9d942c9 	.word	0xc9d942c9
 800257c:	d9c9c9c9 	.word	0xd9c9c9c9
 8002580:	c9c9c9c9 	.word	0xc9c9c9c9
 8002584:	c9c9c4c9 	.word	0xc9c9c4c9
 8002588:	95c91fc9 	.word	0x95c91fc9
 800258c:	c9c9      	.short	0xc9c9
 800258e:	d6          	.byte	0xd6
 800258f:	00          	.byte	0x00
      if (*fmt)
 8002590:	460b      	mov	r3, r1
 8002592:	4676      	mov	r6, lr
 8002594:	e7da      	b.n	800254c <chvprintf+0x13c>
    switch (c) {
 8002596:	4676      	mov	r6, lr
      if ((s = va_arg(ap, char *)) == 0)
 8002598:	f8d8 9000 	ldr.w	r9, [r8]
 800259c:	f108 0804 	add.w	r8, r8, #4
 80025a0:	f1b9 0f00 	cmp.w	r9, #0
 80025a4:	f000 80ff 	beq.w	80027a6 <chvprintf+0x396>
 80025a8:	f899 3000 	ldrb.w	r3, [r9]
 80025ac:	4648      	mov	r0, r9
      if (precision == 0)
 80025ae:	2a00      	cmp	r2, #0
 80025b0:	f040 8100 	bne.w	80027b4 <chvprintf+0x3a4>
      for (p = s; *p && (--precision >= 0); p++)
 80025b4:	2b00      	cmp	r3, #0
 80025b6:	f000 810e 	beq.w	80027d6 <chvprintf+0x3c6>
 80025ba:	f647 72fe 	movw	r2, #32766	; 0x7ffe
 80025be:	464b      	mov	r3, r9
 80025c0:	e001      	b.n	80025c6 <chvprintf+0x1b6>
 80025c2:	3a01      	subs	r2, #1
 80025c4:	d403      	bmi.n	80025ce <chvprintf+0x1be>
 80025c6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80025ca:	2900      	cmp	r1, #0
 80025cc:	d1f9      	bne.n	80025c2 <chvprintf+0x1b2>
 80025ce:	1a1b      	subs	r3, r3, r0
 80025d0:	1aed      	subs	r5, r5, r3
 80025d2:	3b01      	subs	r3, #1
 80025d4:	9300      	str	r3, [sp, #0]
      filler = ' ';
 80025d6:	f04f 0a20 	mov.w	sl, #32
 80025da:	e00d      	b.n	80025f8 <chvprintf+0x1e8>
    switch (c) {
 80025dc:	4676      	mov	r6, lr
      *p++ = va_arg(ap, int);
 80025de:	f10d 0918 	add.w	r9, sp, #24
 80025e2:	f8d8 3000 	ldr.w	r3, [r8]
 80025e6:	f809 3d0c 	strb.w	r3, [r9, #-12]!
      break;
 80025ea:	2300      	movs	r3, #0
 80025ec:	3d01      	subs	r5, #1
      *p++ = va_arg(ap, int);
 80025ee:	f108 0804 	add.w	r8, r8, #4
      break;
 80025f2:	9300      	str	r3, [sp, #0]
      filler = ' ';
 80025f4:	f04f 0a20 	mov.w	sl, #32
    if ((width -= i) < 0)
 80025f8:	2d00      	cmp	r5, #0
 80025fa:	db1e      	blt.n	800263a <chvprintf+0x22a>
    if (left_align == FALSE)
 80025fc:	f1bc 0f00 	cmp.w	ip, #0
 8002600:	d17d      	bne.n	80026fe <chvprintf+0x2ee>
      width = -width;
 8002602:	426b      	negs	r3, r5
    if (width < 0) {
 8002604:	2d00      	cmp	r5, #0
 8002606:	d079      	beq.n	80026fc <chvprintf+0x2ec>
      if (*s == '-' && filler == '0') {
 8002608:	f899 1000 	ldrb.w	r1, [r9]
 800260c:	6822      	ldr	r2, [r4, #0]
 800260e:	292d      	cmp	r1, #45	; 0x2d
 8002610:	68d2      	ldr	r2, [r2, #12]
 8002612:	f000 80a9 	beq.w	8002768 <chvprintf+0x358>
 8002616:	469b      	mov	fp, r3
 8002618:	e001      	b.n	800261e <chvprintf+0x20e>
 800261a:	6823      	ldr	r3, [r4, #0]
 800261c:	68da      	ldr	r2, [r3, #12]
        streamPut(chp, (uint8_t)filler);
 800261e:	4651      	mov	r1, sl
 8002620:	4620      	mov	r0, r4
 8002622:	4790      	blx	r2
      } while (++width != 0);
 8002624:	f11b 0b01 	adds.w	fp, fp, #1
 8002628:	d1f7      	bne.n	800261a <chvprintf+0x20a>
    while (--i >= 0) {
 800262a:	9a00      	ldr	r2, [sp, #0]
 800262c:	2a00      	cmp	r2, #0
 800262e:	465b      	mov	r3, fp
 8002630:	442f      	add	r7, r5
 8002632:	f6ff aef4 	blt.w	800241e <chvprintf+0xe>
 8002636:	461d      	mov	r5, r3
 8002638:	e004      	b.n	8002644 <chvprintf+0x234>
 800263a:	9b00      	ldr	r3, [sp, #0]
 800263c:	2b00      	cmp	r3, #0
 800263e:	f6ff aeee 	blt.w	800241e <chvprintf+0xe>
      width = 0;
 8002642:	2500      	movs	r5, #0
      width = -width;
 8002644:	f8dd b000 	ldr.w	fp, [sp]
      streamPut(chp, (uint8_t)*s++);
 8002648:	6823      	ldr	r3, [r4, #0]
 800264a:	f819 1b01 	ldrb.w	r1, [r9], #1
 800264e:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8002650:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
      streamPut(chp, (uint8_t)*s++);
 8002654:	4620      	mov	r0, r4
 8002656:	4798      	blx	r3
    while (--i >= 0) {
 8002658:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
 800265c:	d1f4      	bne.n	8002648 <chvprintf+0x238>
 800265e:	9b00      	ldr	r3, [sp, #0]
 8002660:	3701      	adds	r7, #1
 8002662:	443b      	add	r3, r7
 8002664:	461f      	mov	r7, r3
    while (width) {
 8002666:	2d00      	cmp	r5, #0
 8002668:	f43f aed9 	beq.w	800241e <chvprintf+0xe>
 800266c:	46a9      	mov	r9, r5
      streamPut(chp, (uint8_t)filler);
 800266e:	6823      	ldr	r3, [r4, #0]
 8002670:	4651      	mov	r1, sl
 8002672:	68db      	ldr	r3, [r3, #12]
 8002674:	4620      	mov	r0, r4
 8002676:	4798      	blx	r3
    while (width) {
 8002678:	f1b9 0901 	subs.w	r9, r9, #1
 800267c:	d1f7      	bne.n	800266e <chvprintf+0x25e>
 800267e:	442f      	add	r7, r5
 8002680:	e6cd      	b.n	800241e <chvprintf+0xe>
    switch (c) {
 8002682:	4676      	mov	r6, lr
      goto unsigned_common;
 8002684:	f04f 090a 	mov.w	r9, #10
 8002688:	f858 2b04 	ldr.w	r2, [r8], #4
  q = p + MAX_FILLER;
 800268c:	f10d 0117 	add.w	r1, sp, #23
 8002690:	e000      	b.n	8002694 <chvprintf+0x284>
  } while ((ll /= radix) != 0);
 8002692:	4601      	mov	r1, r0
    i = (int)(l % radix);
 8002694:	fbb2 fef9 	udiv	lr, r2, r9
 8002698:	fb09 221e 	mls	r2, r9, lr, r2
    i += '0';
 800269c:	f102 0330 	add.w	r3, r2, #48	; 0x30
    if (i > '9')
 80026a0:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 80026a2:	bfc8      	it	gt
 80026a4:	f102 0337 	addgt.w	r3, r2, #55	; 0x37
    *--q = i;
 80026a8:	b2db      	uxtb	r3, r3
    l /= radix;
 80026aa:	4672      	mov	r2, lr
    *--q = i;
 80026ac:	f801 3c01 	strb.w	r3, [r1, #-1]
 80026b0:	1e48      	subs	r0, r1, #1
  } while ((ll /= radix) != 0);
 80026b2:	2a00      	cmp	r2, #0
 80026b4:	d1ed      	bne.n	8002692 <chvprintf+0x282>
  i = (int)(p + MAX_FILLER - q);
 80026b6:	f10d 0217 	add.w	r2, sp, #23
 80026ba:	eba2 0b00 	sub.w	fp, r2, r0
 80026be:	f10d 090c 	add.w	r9, sp, #12
 80026c2:	464a      	mov	r2, r9
 80026c4:	4458      	add	r0, fp
 80026c6:	e001      	b.n	80026cc <chvprintf+0x2bc>
 80026c8:	f811 3b01 	ldrb.w	r3, [r1], #1
    *p++ = *q++;
 80026cc:	f802 3b01 	strb.w	r3, [r2], #1
  while (--i);
 80026d0:	4281      	cmp	r1, r0
 80026d2:	d1f9      	bne.n	80026c8 <chvprintf+0x2b8>
 80026d4:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
 80026d8:	eba5 050b 	sub.w	r5, r5, fp
 80026dc:	9300      	str	r3, [sp, #0]
 80026de:	e78b      	b.n	80025f8 <chvprintf+0x1e8>
    switch (c) {
 80026e0:	4676      	mov	r6, lr
    case 'O':
 80026e2:	f04f 0908 	mov.w	r9, #8
 80026e6:	e7cf      	b.n	8002688 <chvprintf+0x278>
    switch (c) {
 80026e8:	460b      	mov	r3, r1
 80026ea:	4676      	mov	r6, lr
      *p++ = c;
 80026ec:	f10d 0918 	add.w	r9, sp, #24
 80026f0:	3d01      	subs	r5, #1
 80026f2:	f809 3d0c 	strb.w	r3, [r9, #-12]!
      break;
 80026f6:	2300      	movs	r3, #0
 80026f8:	9300      	str	r3, [sp, #0]
 80026fa:	e77d      	b.n	80025f8 <chvprintf+0x1e8>
      width = -width;
 80026fc:	461d      	mov	r5, r3
    while (--i >= 0) {
 80026fe:	9b00      	ldr	r3, [sp, #0]
 8002700:	2b00      	cmp	r3, #0
 8002702:	da9f      	bge.n	8002644 <chvprintf+0x234>
 8002704:	e7af      	b.n	8002666 <chvprintf+0x256>
    switch (c) {
 8002706:	f04f 0910 	mov.w	r9, #16
 800270a:	e7bd      	b.n	8002688 <chvprintf+0x278>
 800270c:	f108 0104 	add.w	r1, r8, #4
        l = va_arg(ap, long);
 8002710:	f8d8 2000 	ldr.w	r2, [r8]
 8002714:	4688      	mov	r8, r1
      if (l < 0) {
 8002716:	2a00      	cmp	r2, #0
 8002718:	db54      	blt.n	80027c4 <chvprintf+0x3b4>
    p = tmpbuf;
 800271a:	f10d 090c 	add.w	r9, sp, #12
 800271e:	4648      	mov	r0, r9
  q = p + MAX_FILLER;
 8002720:	f100 030b 	add.w	r3, r0, #11
 8002724:	9300      	str	r3, [sp, #0]
 8002726:	4619      	mov	r1, r3
    i = (int)(l % radix);
 8002728:	4b2e      	ldr	r3, [pc, #184]	; (80027e4 <chvprintf+0x3d4>)
 800272a:	fba3 e302 	umull	lr, r3, r3, r2
 800272e:	08db      	lsrs	r3, r3, #3
 8002730:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
 8002734:	469e      	mov	lr, r3
 8002736:	eba2 034b 	sub.w	r3, r2, fp, lsl #1
    i += '0';
 800273a:	3330      	adds	r3, #48	; 0x30
    *--q = i;
 800273c:	b2db      	uxtb	r3, r3
  } while ((ll /= radix) != 0);
 800273e:	4672      	mov	r2, lr
    *--q = i;
 8002740:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while ((ll /= radix) != 0);
 8002744:	2a00      	cmp	r2, #0
 8002746:	d1ef      	bne.n	8002728 <chvprintf+0x318>
  i = (int)(p + MAX_FILLER - q);
 8002748:	9a00      	ldr	r2, [sp, #0]
 800274a:	1a52      	subs	r2, r2, r1
 800274c:	4402      	add	r2, r0
 800274e:	e001      	b.n	8002754 <chvprintf+0x344>
 8002750:	f811 3f01 	ldrb.w	r3, [r1, #1]!
    *p++ = *q++;
 8002754:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8002758:	4290      	cmp	r0, r2
 800275a:	d1f9      	bne.n	8002750 <chvprintf+0x340>
 800275c:	eba0 0009 	sub.w	r0, r0, r9
 8002760:	1e43      	subs	r3, r0, #1
 8002762:	1a2d      	subs	r5, r5, r0
 8002764:	9300      	str	r3, [sp, #0]
 8002766:	e747      	b.n	80025f8 <chvprintf+0x1e8>
      if (*s == '-' && filler == '0') {
 8002768:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
 800276c:	f47f af53 	bne.w	8002616 <chvprintf+0x206>
        streamPut(chp, (uint8_t)*s++);
 8002770:	4620      	mov	r0, r4
 8002772:	9301      	str	r3, [sp, #4]
 8002774:	4790      	blx	r2
 8002776:	9b00      	ldr	r3, [sp, #0]
 8002778:	6822      	ldr	r2, [r4, #0]
 800277a:	3b01      	subs	r3, #1
 800277c:	9300      	str	r3, [sp, #0]
 800277e:	9b01      	ldr	r3, [sp, #4]
 8002780:	68d2      	ldr	r2, [r2, #12]
 8002782:	3701      	adds	r7, #1
 8002784:	f109 0901 	add.w	r9, r9, #1
 8002788:	469b      	mov	fp, r3
 800278a:	e748      	b.n	800261e <chvprintf+0x20e>
 800278c:	4641      	mov	r1, r8
      if (is_long)
 800278e:	2b19      	cmp	r3, #25
 8002790:	f851 2b04 	ldr.w	r2, [r1], #4
 8002794:	4676      	mov	r6, lr
        l = va_arg(ap, int);
 8002796:	bf88      	it	hi
 8002798:	4688      	movhi	r8, r1
      if (is_long)
 800279a:	d8bc      	bhi.n	8002716 <chvprintf+0x306>
 800279c:	e7b8      	b.n	8002710 <chvprintf+0x300>
    switch (c) {
 800279e:	4676      	mov	r6, lr
 80027a0:	f04f 0910 	mov.w	r9, #16
 80027a4:	e770      	b.n	8002688 <chvprintf+0x278>
 80027a6:	4810      	ldr	r0, [pc, #64]	; (80027e8 <chvprintf+0x3d8>)
      if (precision == 0)
 80027a8:	4681      	mov	r9, r0
 80027aa:	2a00      	cmp	r2, #0
 80027ac:	f43f af05 	beq.w	80025ba <chvprintf+0x1aa>
      for (p = s; *p && (--precision >= 0); p++)
 80027b0:	3a01      	subs	r2, #1
 80027b2:	e704      	b.n	80025be <chvprintf+0x1ae>
 80027b4:	2b00      	cmp	r3, #0
 80027b6:	d1fb      	bne.n	80027b0 <chvprintf+0x3a0>
 80027b8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80027bc:	9300      	str	r3, [sp, #0]
      filler = ' ';
 80027be:	f04f 0a20 	mov.w	sl, #32
 80027c2:	e719      	b.n	80025f8 <chvprintf+0x1e8>
        *p++ = '-';
 80027c4:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 80027c6:	4252      	negs	r2, r2
        *p++ = '-';
 80027c8:	f88d 300c 	strb.w	r3, [sp, #12]
 80027cc:	f10d 000d 	add.w	r0, sp, #13
 80027d0:	f10d 090c 	add.w	r9, sp, #12
 80027d4:	e7a4      	b.n	8002720 <chvprintf+0x310>
      for (p = s; *p && (--precision >= 0); p++)
 80027d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80027da:	9300      	str	r3, [sp, #0]
      filler = ' ';
 80027dc:	f04f 0a20 	mov.w	sl, #32
 80027e0:	e70c      	b.n	80025fc <chvprintf+0x1ec>
 80027e2:	bf00      	nop
 80027e4:	cccccccd 	.word	0xcccccccd
 80027e8:	08003340 	.word	0x08003340
 80027ec:	00000000 	.word	0x00000000

080027f0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80027f0:	b40e      	push	{r1, r2, r3}
 80027f2:	b500      	push	{lr}
 80027f4:	b082      	sub	sp, #8
 80027f6:	aa03      	add	r2, sp, #12
 80027f8:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80027fc:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80027fe:	f7ff fe07 	bl	8002410 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8002802:	b002      	add	sp, #8
 8002804:	f85d eb04 	ldr.w	lr, [sp], #4
 8002808:	b003      	add	sp, #12
 800280a:	4770      	bx	lr
 800280c:	0000      	movs	r0, r0
	...

08002810 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8002810:	b570      	push	{r4, r5, r6, lr}
 8002812:	460e      	mov	r6, r1
  char *p;

  if (str != NULL)
 8002814:	b1f0      	cbz	r0, 8002854 <parse_arguments+0x44>
 8002816:	4604      	mov	r4, r0
    *saveptr = str;
 8002818:	6030      	str	r0, [r6, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 800281a:	4911      	ldr	r1, [pc, #68]	; (8002860 <parse_arguments+0x50>)
 800281c:	4620      	mov	r0, r4
 800281e:	f000 fcfb 	bl	8003218 <strspn>

  if (*p == '"') {
 8002822:	5c21      	ldrb	r1, [r4, r0]
 8002824:	2922      	cmp	r1, #34	; 0x22
  p += strspn(p, " \t");
 8002826:	eb04 0500 	add.w	r5, r4, r0
  if (*p == '"') {
 800282a:	d00d      	beq.n	8002848 <parse_arguments+0x38>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 800282c:	490c      	ldr	r1, [pc, #48]	; (8002860 <parse_arguments+0x50>)
 800282e:	4628      	mov	r0, r5
 8002830:	f000 fcd0 	bl	80031d4 <strpbrk>
 8002834:	6030      	str	r0, [r6, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 8002836:	b118      	cbz	r0, 8002840 <parse_arguments+0x30>
    *(*saveptr)++ = '\0';
 8002838:	1c42      	adds	r2, r0, #1
 800283a:	2300      	movs	r3, #0
 800283c:	6032      	str	r2, [r6, #0]
 800283e:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
 8002840:	782b      	ldrb	r3, [r5, #0]
 8002842:	b153      	cbz	r3, 800285a <parse_arguments+0x4a>
}
 8002844:	4628      	mov	r0, r5
 8002846:	bd70      	pop	{r4, r5, r6, pc}
    p++;
 8002848:	3501      	adds	r5, #1
    *saveptr = strpbrk(p, "\"");
 800284a:	4628      	mov	r0, r5
 800284c:	f000 fc4e 	bl	80030ec <strchr>
 8002850:	6030      	str	r0, [r6, #0]
 8002852:	e7f0      	b.n	8002836 <parse_arguments+0x26>
  p = *saveptr;
 8002854:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8002856:	2c00      	cmp	r4, #0
 8002858:	d1df      	bne.n	800281a <parse_arguments+0xa>
  return *p != '\0' ? p : NULL;
 800285a:	2500      	movs	r5, #0
}
 800285c:	4628      	mov	r0, r5
 800285e:	bd70      	pop	{r4, r5, r6, pc}
 8002860:	08003348 	.word	0x08003348
	...

08002870 <shellInit>:
 8002870:	4b01      	ldr	r3, [pc, #4]	; (8002878 <shellInit+0x8>)
 8002872:	601b      	str	r3, [r3, #0]
 * @api
 */
void shellInit(void) {

  chEvtObjectInit(&shell_terminated);
}
 8002874:	4770      	bx	lr
 8002876:	bf00      	nop
 8002878:	20000a60 	.word	0x20000a60
 800287c:	00000000 	.word	0x00000000

08002880 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
 8002880:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
 8002884:	6804      	ldr	r4, [r0, #0]
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8002886:	3a01      	subs	r2, #1
 8002888:	6825      	ldr	r5, [r4, #0]
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
 800288a:	b082      	sub	sp, #8
 800288c:	4688      	mov	r8, r1
    if (p < line + size - 1) {
 800288e:	188f      	adds	r7, r1, r2
  BaseSequentialStream *chp = scfg->sc_channel;
 8002890:	460e      	mov	r6, r1
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8002892:	68ab      	ldr	r3, [r5, #8]
 8002894:	2201      	movs	r2, #1
 8002896:	f10d 0107 	add.w	r1, sp, #7
 800289a:	4620      	mov	r0, r4
 800289c:	4798      	blx	r3
 800289e:	b358      	cbz	r0, 80028f8 <shellGetLine+0x78>
    if ((c == 8) || (c == 127)) {
 80028a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80028a4:	2b08      	cmp	r3, #8
 80028a6:	d012      	beq.n	80028ce <shellGetLine+0x4e>
 80028a8:	2b7f      	cmp	r3, #127	; 0x7f
      streamPut(chp, c);
 80028aa:	4619      	mov	r1, r3
 80028ac:	4620      	mov	r0, r4
    if ((c == 8) || (c == 127)) {
 80028ae:	d00e      	beq.n	80028ce <shellGetLine+0x4e>
    if (c == '\r') {
 80028b0:	2b0d      	cmp	r3, #13
 80028b2:	d025      	beq.n	8002900 <shellGetLine+0x80>
    if (c < 0x20)
 80028b4:	2b1f      	cmp	r3, #31
 80028b6:	6825      	ldr	r5, [r4, #0]
 80028b8:	d9eb      	bls.n	8002892 <shellGetLine+0x12>
    if (p < line + size - 1) {
 80028ba:	42be      	cmp	r6, r7
 80028bc:	d2e9      	bcs.n	8002892 <shellGetLine+0x12>
      streamPut(chp, c);
 80028be:	68eb      	ldr	r3, [r5, #12]
 80028c0:	4798      	blx	r3
      *p++ = (char)c;
 80028c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80028c6:	7033      	strb	r3, [r6, #0]
 80028c8:	6825      	ldr	r5, [r4, #0]
 80028ca:	3601      	adds	r6, #1
 80028cc:	e7e1      	b.n	8002892 <shellGetLine+0x12>
      if (p != line) {
 80028ce:	4546      	cmp	r6, r8
        streamPut(chp, 0x08);
 80028d0:	f04f 0108 	mov.w	r1, #8
 80028d4:	4620      	mov	r0, r4
 80028d6:	6825      	ldr	r5, [r4, #0]
      if (p != line) {
 80028d8:	d0db      	beq.n	8002892 <shellGetLine+0x12>
        streamPut(chp, 0x08);
 80028da:	68eb      	ldr	r3, [r5, #12]
 80028dc:	4798      	blx	r3
        streamPut(chp, 0x20);
 80028de:	6823      	ldr	r3, [r4, #0]
 80028e0:	2120      	movs	r1, #32
 80028e2:	68db      	ldr	r3, [r3, #12]
 80028e4:	4620      	mov	r0, r4
 80028e6:	4798      	blx	r3
        streamPut(chp, 0x08);
 80028e8:	6823      	ldr	r3, [r4, #0]
 80028ea:	2108      	movs	r1, #8
 80028ec:	68db      	ldr	r3, [r3, #12]
 80028ee:	4620      	mov	r0, r4
 80028f0:	4798      	blx	r3
        p--;
 80028f2:	3e01      	subs	r6, #1
 80028f4:	6825      	ldr	r5, [r4, #0]
 80028f6:	e7cc      	b.n	8002892 <shellGetLine+0x12>
      return true;
 80028f8:	2001      	movs	r0, #1
    }
  }
}
 80028fa:	b002      	add	sp, #8
 80028fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      chprintf(chp, SHELL_NEWLINE_STR);
 8002900:	4903      	ldr	r1, [pc, #12]	; (8002910 <shellGetLine+0x90>)
 8002902:	f7ff ff75 	bl	80027f0 <chprintf>
      *p = 0;
 8002906:	2000      	movs	r0, #0
 8002908:	7030      	strb	r0, [r6, #0]
}
 800290a:	b002      	add	sp, #8
 800290c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002910:	0800335c 	.word	0x0800335c
	...

08002920 <shellThread>:
THD_FUNCTION(shellThread, p) {
 8002920:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const ShellCommand *scp = scfg->sc_commands;
 8002924:	e9d0 5300 	ldrd	r5, r3, [r0]
THD_FUNCTION(shellThread, p) {
 8002928:	b099      	sub	sp, #100	; 0x64
  chprintf(chp, SHELL_NEWLINE_STR);
 800292a:	4953      	ldr	r1, [pc, #332]	; (8002a78 <shellThread+0x158>)
  const ShellCommand *scp = scfg->sc_commands;
 800292c:	9301      	str	r3, [sp, #4]
THD_FUNCTION(shellThread, p) {
 800292e:	4607      	mov	r7, r0
  chprintf(chp, SHELL_NEWLINE_STR);
 8002930:	4628      	mov	r0, r5
 8002932:	f7ff ff5d 	bl	80027f0 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8002936:	4628      	mov	r0, r5
 8002938:	4950      	ldr	r1, [pc, #320]	; (8002a7c <shellThread+0x15c>)
    chprintf(chp, SHELL_PROMPT_STR);
 800293a:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8002a9c <shellThread+0x17c>
      if (strcmp(cmd, "help") == 0) {
 800293e:	f8df a160 	ldr.w	sl, [pc, #352]	; 8002aa0 <shellThread+0x180>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
 8002942:	f7ff ff55 	bl	80027f0 <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 8002946:	f04f 0900 	mov.w	r9, #0
    chprintf(chp, SHELL_PROMPT_STR);
 800294a:	4641      	mov	r1, r8
 800294c:	4628      	mov	r0, r5
 800294e:	f7ff ff4f 	bl	80027f0 <chprintf>
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
 8002952:	2300      	movs	r3, #0
 8002954:	2240      	movs	r2, #64	; 0x40
 8002956:	a908      	add	r1, sp, #32
 8002958:	4638      	mov	r0, r7
 800295a:	f7ff ff91 	bl	8002880 <shellGetLine>
 800295e:	2800      	cmp	r0, #0
 8002960:	d135      	bne.n	80029ce <shellThread+0xae>
    lp = parse_arguments(line, &tokp);
 8002962:	a902      	add	r1, sp, #8
 8002964:	a808      	add	r0, sp, #32
 8002966:	f7ff ff53 	bl	8002810 <parse_arguments>
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800296a:	a902      	add	r1, sp, #8
    lp = parse_arguments(line, &tokp);
 800296c:	4606      	mov	r6, r0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800296e:	2000      	movs	r0, #0
 8002970:	ac03      	add	r4, sp, #12
    n = 0;
 8002972:	f04f 0b00 	mov.w	fp, #0
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8002976:	f7ff ff4b 	bl	8002810 <parse_arguments>
 800297a:	b160      	cbz	r0, 8002996 <shellThread+0x76>
      if (n >= SHELL_MAX_ARGUMENTS) {
 800297c:	f1bb 0f04 	cmp.w	fp, #4
 8002980:	d01e      	beq.n	80029c0 <shellThread+0xa0>
      args[n++] = lp;
 8002982:	f844 0b04 	str.w	r0, [r4], #4
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8002986:	a902      	add	r1, sp, #8
 8002988:	2000      	movs	r0, #0
      args[n++] = lp;
 800298a:	f10b 0b01 	add.w	fp, fp, #1
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800298e:	f7ff ff3f 	bl	8002810 <parse_arguments>
 8002992:	2800      	cmp	r0, #0
 8002994:	d1f2      	bne.n	800297c <shellThread+0x5c>
    args[n] = NULL;
 8002996:	ab18      	add	r3, sp, #96	; 0x60
 8002998:	eb03 028b 	add.w	r2, r3, fp, lsl #2
 800299c:	f842 0c54 	str.w	r0, [r2, #-84]
    if (cmd != NULL) {
 80029a0:	2e00      	cmp	r6, #0
 80029a2:	d0d2      	beq.n	800294a <shellThread+0x2a>
      if (strcmp(cmd, "help") == 0) {
 80029a4:	4651      	mov	r1, sl
 80029a6:	4630      	mov	r0, r6
 80029a8:	f7fd fece 	bl	8000748 <strcmp>
 80029ac:	b9a0      	cbnz	r0, 80029d8 <shellThread+0xb8>
        if (n > 0) {
 80029ae:	f1bb 0f00 	cmp.w	fp, #0
 80029b2:	d025      	beq.n	8002a00 <shellThread+0xe0>
          shellUsage(chp, "help");
 80029b4:	4652      	mov	r2, sl
 80029b6:	4932      	ldr	r1, [pc, #200]	; (8002a80 <shellThread+0x160>)
 80029b8:	4628      	mov	r0, r5
 80029ba:	f7ff ff19 	bl	80027f0 <chprintf>
          continue;
 80029be:	e7c4      	b.n	800294a <shellThread+0x2a>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
 80029c0:	4930      	ldr	r1, [pc, #192]	; (8002a84 <shellThread+0x164>)
 80029c2:	4628      	mov	r0, r5
 80029c4:	f7ff ff14 	bl	80027f0 <chprintf>
    args[n] = NULL;
 80029c8:	f8cd 901c 	str.w	r9, [sp, #28]
 80029cc:	e7bd      	b.n	800294a <shellThread+0x2a>
  chThdSleep(delay);
 80029ce:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80029d2:	f7ff f9fd 	bl	8001dd0 <chThdSleep>
 80029d6:	e7c4      	b.n	8002962 <shellThread+0x42>
  while (scp->sc_name != NULL) {
 80029d8:	4b2b      	ldr	r3, [pc, #172]	; (8002a88 <shellThread+0x168>)
 80029da:	6818      	ldr	r0, [r3, #0]
 80029dc:	2800      	cmp	r0, #0
 80029de:	d032      	beq.n	8002a46 <shellThread+0x126>
 80029e0:	4c29      	ldr	r4, [pc, #164]	; (8002a88 <shellThread+0x168>)
 80029e2:	e002      	b.n	80029ea <shellThread+0xca>
 80029e4:	f854 0f08 	ldr.w	r0, [r4, #8]!
 80029e8:	b368      	cbz	r0, 8002a46 <shellThread+0x126>
    if (strcmp(scp->sc_name, name) == 0) {
 80029ea:	4631      	mov	r1, r6
 80029ec:	f7fd feac 	bl	8000748 <strcmp>
 80029f0:	2800      	cmp	r0, #0
 80029f2:	d1f7      	bne.n	80029e4 <shellThread+0xc4>
      scp->sc_function(chp, argc, argv);
 80029f4:	6864      	ldr	r4, [r4, #4]
 80029f6:	4659      	mov	r1, fp
 80029f8:	aa03      	add	r2, sp, #12
 80029fa:	4628      	mov	r0, r5
 80029fc:	47a0      	blx	r4
 80029fe:	e7a4      	b.n	800294a <shellThread+0x2a>
        chprintf(chp, "Commands: help ");
 8002a00:	4922      	ldr	r1, [pc, #136]	; (8002a8c <shellThread+0x16c>)
 8002a02:	4628      	mov	r0, r5
 8002a04:	f7ff fef4 	bl	80027f0 <chprintf>
  while (scp->sc_name != NULL) {
 8002a08:	4b1f      	ldr	r3, [pc, #124]	; (8002a88 <shellThread+0x168>)
 8002a0a:	681a      	ldr	r2, [r3, #0]
 8002a0c:	b14a      	cbz	r2, 8002a22 <shellThread+0x102>
    chprintf(chp, "%s ", scp->sc_name);
 8002a0e:	4c20      	ldr	r4, [pc, #128]	; (8002a90 <shellThread+0x170>)
 8002a10:	461e      	mov	r6, r3
 8002a12:	4621      	mov	r1, r4
 8002a14:	4628      	mov	r0, r5
 8002a16:	f7ff feeb 	bl	80027f0 <chprintf>
  while (scp->sc_name != NULL) {
 8002a1a:	f856 2f08 	ldr.w	r2, [r6, #8]!
 8002a1e:	2a00      	cmp	r2, #0
 8002a20:	d1f7      	bne.n	8002a12 <shellThread+0xf2>
        if (scp != NULL)
 8002a22:	9e01      	ldr	r6, [sp, #4]
 8002a24:	b156      	cbz	r6, 8002a3c <shellThread+0x11c>
  while (scp->sc_name != NULL) {
 8002a26:	6832      	ldr	r2, [r6, #0]
 8002a28:	b142      	cbz	r2, 8002a3c <shellThread+0x11c>
    chprintf(chp, "%s ", scp->sc_name);
 8002a2a:	4c19      	ldr	r4, [pc, #100]	; (8002a90 <shellThread+0x170>)
 8002a2c:	4621      	mov	r1, r4
 8002a2e:	4628      	mov	r0, r5
 8002a30:	f7ff fede 	bl	80027f0 <chprintf>
  while (scp->sc_name != NULL) {
 8002a34:	f856 2f08 	ldr.w	r2, [r6, #8]!
 8002a38:	2a00      	cmp	r2, #0
 8002a3a:	d1f7      	bne.n	8002a2c <shellThread+0x10c>
        chprintf(chp, SHELL_NEWLINE_STR);
 8002a3c:	490e      	ldr	r1, [pc, #56]	; (8002a78 <shellThread+0x158>)
 8002a3e:	4628      	mov	r0, r5
 8002a40:	f7ff fed6 	bl	80027f0 <chprintf>
 8002a44:	e781      	b.n	800294a <shellThread+0x2a>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 8002a46:	9c01      	ldr	r4, [sp, #4]
 8002a48:	b15c      	cbz	r4, 8002a62 <shellThread+0x142>
  while (scp->sc_name != NULL) {
 8002a4a:	6820      	ldr	r0, [r4, #0]
 8002a4c:	b918      	cbnz	r0, 8002a56 <shellThread+0x136>
 8002a4e:	e008      	b.n	8002a62 <shellThread+0x142>
 8002a50:	f854 0f08 	ldr.w	r0, [r4, #8]!
 8002a54:	b128      	cbz	r0, 8002a62 <shellThread+0x142>
    if (strcmp(scp->sc_name, name) == 0) {
 8002a56:	4631      	mov	r1, r6
 8002a58:	f7fd fe76 	bl	8000748 <strcmp>
 8002a5c:	2800      	cmp	r0, #0
 8002a5e:	d1f7      	bne.n	8002a50 <shellThread+0x130>
 8002a60:	e7c8      	b.n	80029f4 <shellThread+0xd4>
        chprintf(chp, "%s", cmd);
 8002a62:	4632      	mov	r2, r6
 8002a64:	490b      	ldr	r1, [pc, #44]	; (8002a94 <shellThread+0x174>)
 8002a66:	4628      	mov	r0, r5
 8002a68:	f7ff fec2 	bl	80027f0 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
 8002a6c:	490a      	ldr	r1, [pc, #40]	; (8002a98 <shellThread+0x178>)
 8002a6e:	4628      	mov	r0, r5
 8002a70:	f7ff febe 	bl	80027f0 <chprintf>
 8002a74:	e769      	b.n	800294a <shellThread+0x2a>
 8002a76:	bf00      	nop
 8002a78:	0800335c 	.word	0x0800335c
 8002a7c:	0800334c 	.word	0x0800334c
 8002a80:	08003388 	.word	0x08003388
 8002a84:	08003368 	.word	0x08003368
 8002a88:	08003664 	.word	0x08003664
 8002a8c:	08003394 	.word	0x08003394
 8002a90:	080033a4 	.word	0x080033a4
 8002a94:	080033a8 	.word	0x080033a8
 8002a98:	080033ac 	.word	0x080033ac
 8002a9c:	08003360 	.word	0x08003360
 8002aa0:	08003380 	.word	0x08003380
	...

08002ab0 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002ab0:	2900      	cmp	r1, #0
 8002ab2:	dd03      	ble.n	8002abc <cmd_systime+0xc>
    shellUsage(chp, "systime");
 8002ab4:	4a07      	ldr	r2, [pc, #28]	; (8002ad4 <cmd_systime+0x24>)
 8002ab6:	4908      	ldr	r1, [pc, #32]	; (8002ad8 <cmd_systime+0x28>)
 8002ab8:	f7ff be9a 	b.w	80027f0 <chprintf>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002abc:	2320      	movs	r3, #32
 8002abe:	f383 8811 	msr	BASEPRI, r3
 8002ac2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002ac6:	2300      	movs	r3, #0
 8002ac8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8002aca:	f383 8811 	msr	BASEPRI, r3
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8002ace:	4903      	ldr	r1, [pc, #12]	; (8002adc <cmd_systime+0x2c>)
 8002ad0:	f7ff be8e 	b.w	80027f0 <chprintf>
 8002ad4:	080035e4 	.word	0x080035e4
 8002ad8:	08003388 	.word	0x08003388
 8002adc:	080035ec 	.word	0x080035ec

08002ae0 <cmd_echo>:
  if (argc != 1) {
 8002ae0:	2901      	cmp	r1, #1
 8002ae2:	d003      	beq.n	8002aec <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
 8002ae4:	4a03      	ldr	r2, [pc, #12]	; (8002af4 <cmd_echo+0x14>)
 8002ae6:	4904      	ldr	r1, [pc, #16]	; (8002af8 <cmd_echo+0x18>)
 8002ae8:	f7ff be82 	b.w	80027f0 <chprintf>
  chprintf(chp, "%s" SHELL_NEWLINE_STR, argv[0]);
 8002aec:	6812      	ldr	r2, [r2, #0]
 8002aee:	4903      	ldr	r1, [pc, #12]	; (8002afc <cmd_echo+0x1c>)
 8002af0:	f7ff be7e 	b.w	80027f0 <chprintf>
 8002af4:	080033b4 	.word	0x080033b4
 8002af8:	08003388 	.word	0x08003388
 8002afc:	080033c4 	.word	0x080033c4

08002b00 <cmd_info>:
  if (argc > 0) {
 8002b00:	2900      	cmp	r1, #0
 8002b02:	dd03      	ble.n	8002b0c <cmd_info+0xc>
    shellUsage(chp, "info");
 8002b04:	4a19      	ldr	r2, [pc, #100]	; (8002b6c <cmd_info+0x6c>)
 8002b06:	491a      	ldr	r1, [pc, #104]	; (8002b70 <cmd_info+0x70>)
 8002b08:	f7ff be72 	b.w	80027f0 <chprintf>
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002b0c:	b510      	push	{r4, lr}
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8002b0e:	4a19      	ldr	r2, [pc, #100]	; (8002b74 <cmd_info+0x74>)
 8002b10:	4919      	ldr	r1, [pc, #100]	; (8002b78 <cmd_info+0x78>)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002b12:	b082      	sub	sp, #8
 8002b14:	4604      	mov	r4, r0
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8002b16:	f7ff fe6b 	bl	80027f0 <chprintf>
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8002b1a:	4a18      	ldr	r2, [pc, #96]	; (8002b7c <cmd_info+0x7c>)
 8002b1c:	4918      	ldr	r1, [pc, #96]	; (8002b80 <cmd_info+0x80>)
 8002b1e:	4620      	mov	r0, r4
 8002b20:	f7ff fe66 	bl	80027f0 <chprintf>
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8002b24:	4a17      	ldr	r2, [pc, #92]	; (8002b84 <cmd_info+0x84>)
 8002b26:	4918      	ldr	r1, [pc, #96]	; (8002b88 <cmd_info+0x88>)
 8002b28:	4620      	mov	r0, r4
 8002b2a:	f7ff fe61 	bl	80027f0 <chprintf>
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8002b2e:	4a17      	ldr	r2, [pc, #92]	; (8002b8c <cmd_info+0x8c>)
 8002b30:	4917      	ldr	r1, [pc, #92]	; (8002b90 <cmd_info+0x90>)
 8002b32:	4620      	mov	r0, r4
 8002b34:	f7ff fe5c 	bl	80027f0 <chprintf>
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
 8002b38:	4a16      	ldr	r2, [pc, #88]	; (8002b94 <cmd_info+0x94>)
 8002b3a:	4917      	ldr	r1, [pc, #92]	; (8002b98 <cmd_info+0x98>)
 8002b3c:	4620      	mov	r0, r4
 8002b3e:	f7ff fe57 	bl	80027f0 <chprintf>
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
 8002b42:	4a16      	ldr	r2, [pc, #88]	; (8002b9c <cmd_info+0x9c>)
 8002b44:	4916      	ldr	r1, [pc, #88]	; (8002ba0 <cmd_info+0xa0>)
 8002b46:	4620      	mov	r0, r4
 8002b48:	f7ff fe52 	bl	80027f0 <chprintf>
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
 8002b4c:	4a15      	ldr	r2, [pc, #84]	; (8002ba4 <cmd_info+0xa4>)
 8002b4e:	4916      	ldr	r1, [pc, #88]	; (8002ba8 <cmd_info+0xa8>)
 8002b50:	4620      	mov	r0, r4
 8002b52:	f7ff fe4d 	bl	80027f0 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8002b56:	4b15      	ldr	r3, [pc, #84]	; (8002bac <cmd_info+0xac>)
 8002b58:	9300      	str	r3, [sp, #0]
 8002b5a:	4620      	mov	r0, r4
 8002b5c:	4b14      	ldr	r3, [pc, #80]	; (8002bb0 <cmd_info+0xb0>)
 8002b5e:	4a15      	ldr	r2, [pc, #84]	; (8002bb4 <cmd_info+0xb4>)
 8002b60:	4915      	ldr	r1, [pc, #84]	; (8002bb8 <cmd_info+0xb8>)
 8002b62:	f7ff fe45 	bl	80027f0 <chprintf>
}
 8002b66:	b002      	add	sp, #8
 8002b68:	bd10      	pop	{r4, pc}
 8002b6a:	bf00      	nop
 8002b6c:	080033cc 	.word	0x080033cc
 8002b70:	08003388 	.word	0x08003388
 8002b74:	080033d4 	.word	0x080033d4
 8002b78:	080033dc 	.word	0x080033dc
 8002b7c:	080033f0 	.word	0x080033f0
 8002b80:	08003438 	.word	0x08003438
 8002b84:	0800344c 	.word	0x0800344c
 8002b88:	08003458 	.word	0x08003458
 8002b8c:	0800346c 	.word	0x0800346c
 8002b90:	08003478 	.word	0x08003478
 8002b94:	0800348c 	.word	0x0800348c
 8002b98:	080034a4 	.word	0x080034a4
 8002b9c:	080034b8 	.word	0x080034b8
 8002ba0:	080034e4 	.word	0x080034e4
 8002ba4:	080034f8 	.word	0x080034f8
 8002ba8:	08003520 	.word	0x08003520
 8002bac:	0800355c 	.word	0x0800355c
 8002bb0:	08003534 	.word	0x08003534
 8002bb4:	08003538 	.word	0x08003538
 8002bb8:	08003544 	.word	0x08003544
 8002bbc:	00000000 	.word	0x00000000

08002bc0 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8002bc0:	2900      	cmp	r1, #0
 8002bc2:	dd03      	ble.n	8002bcc <cmd_threads+0xc>
    shellUsage(chp, "threads");
 8002bc4:	4a19      	ldr	r2, [pc, #100]	; (8002c2c <cmd_threads+0x6c>)
 8002bc6:	491a      	ldr	r1, [pc, #104]	; (8002c30 <cmd_threads+0x70>)
 8002bc8:	f7ff be12 	b.w	80027f0 <chprintf>
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002bcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 8002bd0:	4918      	ldr	r1, [pc, #96]	; (8002c34 <cmd_threads+0x74>)
 8002bd2:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8002c38 <cmd_threads+0x78>
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8002bd6:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8002c3c <cmd_threads+0x7c>
 8002bda:	f8df a064 	ldr.w	sl, [pc, #100]	; 8002c40 <cmd_threads+0x80>
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002bde:	b086      	sub	sp, #24
 8002be0:	4606      	mov	r6, r0
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
 8002be2:	f7ff fe05 	bl	80027f0 <chprintf>
  tp = chRegFirstThread();
 8002be6:	f7ff f97b 	bl	8001ee0 <chRegFirstThread>
 8002bea:	4604      	mov	r4, r0
    uint32_t stklimit = (uint32_t)tp->wabase;
 8002bec:	e9d4 1206 	ldrd	r1, r2, [r4, #24]
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8002bf0:	f894 0020 	ldrb.w	r0, [r4, #32]
 8002bf4:	f894 5022 	ldrb.w	r5, [r4, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
 8002bf8:	f859 0020 	ldr.w	r0, [r9, r0, lsl #2]
 8002bfc:	68a7      	ldr	r7, [r4, #8]
 8002bfe:	68e3      	ldr	r3, [r4, #12]
 8002c00:	9400      	str	r4, [sp, #0]
 8002c02:	2900      	cmp	r1, #0
 8002c04:	bf08      	it	eq
 8002c06:	4641      	moveq	r1, r8
 8002c08:	3d01      	subs	r5, #1
 8002c0a:	e9cd 0103 	strd	r0, r1, [sp, #12]
 8002c0e:	9702      	str	r7, [sp, #8]
 8002c10:	4651      	mov	r1, sl
 8002c12:	9501      	str	r5, [sp, #4]
 8002c14:	4630      	mov	r0, r6
 8002c16:	f7ff fdeb 	bl	80027f0 <chprintf>
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
 8002c1a:	4620      	mov	r0, r4
 8002c1c:	f7ff f970 	bl	8001f00 <chRegNextThread>
  } while (tp != NULL);
 8002c20:	4604      	mov	r4, r0
 8002c22:	2800      	cmp	r0, #0
 8002c24:	d1e2      	bne.n	8002bec <cmd_threads+0x2c>
}
 8002c26:	b006      	add	sp, #24
 8002c28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002c2c:	080035f4 	.word	0x080035f4
 8002c30:	08003388 	.word	0x08003388
 8002c34:	080035fc 	.word	0x080035fc
 8002c38:	08003694 	.word	0x08003694
 8002c3c:	080033b0 	.word	0x080033b0
 8002c40:	0800363c 	.word	0x0800363c
	...

08002c50 <cmd_mem>:
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002c50:	b530      	push	{r4, r5, lr}
  if (argc > 0) {
 8002c52:	2900      	cmp	r1, #0
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002c54:	b083      	sub	sp, #12
  if (argc > 0) {
 8002c56:	dd05      	ble.n	8002c64 <cmd_mem+0x14>
    shellUsage(chp, "mem");
 8002c58:	4a12      	ldr	r2, [pc, #72]	; (8002ca4 <cmd_mem+0x54>)
 8002c5a:	4913      	ldr	r1, [pc, #76]	; (8002ca8 <cmd_mem+0x58>)
 8002c5c:	f7ff fdc8 	bl	80027f0 <chprintf>
}
 8002c60:	b003      	add	sp, #12
 8002c62:	bd30      	pop	{r4, r5, pc}
 8002c64:	4604      	mov	r4, r0
  n = chHeapStatus(NULL, &total, &largest);
 8002c66:	aa01      	add	r2, sp, #4
 8002c68:	4669      	mov	r1, sp
 8002c6a:	2000      	movs	r0, #0
 8002c6c:	f7ff fb18 	bl	80022a0 <chHeapStatus>
 8002c70:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes" SHELL_NEWLINE_STR, chCoreGetStatusX());
 8002c72:	f7ff faad 	bl	80021d0 <chCoreGetStatusX>
 8002c76:	490d      	ldr	r1, [pc, #52]	; (8002cac <cmd_mem+0x5c>)
 8002c78:	4602      	mov	r2, r0
 8002c7a:	4620      	mov	r0, r4
 8002c7c:	f7ff fdb8 	bl	80027f0 <chprintf>
  chprintf(chp, "heap fragments   : %u" SHELL_NEWLINE_STR, n);
 8002c80:	462a      	mov	r2, r5
 8002c82:	490b      	ldr	r1, [pc, #44]	; (8002cb0 <cmd_mem+0x60>)
 8002c84:	4620      	mov	r0, r4
 8002c86:	f7ff fdb3 	bl	80027f0 <chprintf>
  chprintf(chp, "heap free total  : %u bytes" SHELL_NEWLINE_STR, total);
 8002c8a:	9a00      	ldr	r2, [sp, #0]
 8002c8c:	4909      	ldr	r1, [pc, #36]	; (8002cb4 <cmd_mem+0x64>)
 8002c8e:	4620      	mov	r0, r4
 8002c90:	f7ff fdae 	bl	80027f0 <chprintf>
  chprintf(chp, "heap free largest: %u bytes" SHELL_NEWLINE_STR, largest);
 8002c94:	4620      	mov	r0, r4
 8002c96:	9a01      	ldr	r2, [sp, #4]
 8002c98:	4907      	ldr	r1, [pc, #28]	; (8002cb8 <cmd_mem+0x68>)
 8002c9a:	f7ff fda9 	bl	80027f0 <chprintf>
}
 8002c9e:	b003      	add	sp, #12
 8002ca0:	bd30      	pop	{r4, r5, pc}
 8002ca2:	bf00      	nop
 8002ca4:	08003568 	.word	0x08003568
 8002ca8:	08003388 	.word	0x08003388
 8002cac:	0800356c 	.word	0x0800356c
 8002cb0:	0800358c 	.word	0x0800358c
 8002cb4:	080035a4 	.word	0x080035a4
 8002cb8:	080035c4 	.word	0x080035c4
 8002cbc:	00000000 	.word	0x00000000

08002cc0 <_ZN10chibios_rt10_thd_startEPv>:
   * chibios_rt::BaseStaticThread                                           *
   *------------------------------------------------------------------------*/

  void _thd_start(void *arg) {

    ((BaseThread *)arg)->main();
 8002cc0:	6803      	ldr	r3, [r0, #0]
 8002cc2:	681b      	ldr	r3, [r3, #0]
 8002cc4:	4718      	bx	r3
 8002cc6:	bf00      	nop
	...

08002cd0 <_Z12portToStringP12stm32_gpio_tmPc>:
#include "port_to_string.hpp"

void portToString(ioportid_t ioportid, ioportmask_t ioportmask, char* result) {
    result[0] = 'P';
    if(ioportid == GPIOA) {
 8002cd0:	4b22      	ldr	r3, [pc, #136]	; (8002d5c <_Z12portToStringP12stm32_gpio_tmPc+0x8c>)
void portToString(ioportid_t ioportid, ioportmask_t ioportmask, char* result) {
 8002cd2:	b410      	push	{r4}
    if(ioportid == GPIOA) {
 8002cd4:	4298      	cmp	r0, r3
    result[0] = 'P';
 8002cd6:	f04f 0450 	mov.w	r4, #80	; 0x50
 8002cda:	7014      	strb	r4, [r2, #0]
    if(ioportid == GPIOA) {
 8002cdc:	d02b      	beq.n	8002d36 <_Z12portToStringP12stm32_gpio_tmPc+0x66>
        result[1] = 'A';
    } else if(ioportid == GPIOB) {
 8002cde:	4b20      	ldr	r3, [pc, #128]	; (8002d60 <_Z12portToStringP12stm32_gpio_tmPc+0x90>)
 8002ce0:	4298      	cmp	r0, r3
 8002ce2:	d014      	beq.n	8002d0e <_Z12portToStringP12stm32_gpio_tmPc+0x3e>
        result[1] = 'B';
    } else if(ioportid == GPIOC) {
 8002ce4:	4b1f      	ldr	r3, [pc, #124]	; (8002d64 <_Z12portToStringP12stm32_gpio_tmPc+0x94>)
 8002ce6:	4298      	cmp	r0, r3
 8002ce8:	d02b      	beq.n	8002d42 <_Z12portToStringP12stm32_gpio_tmPc+0x72>
        result[1] = 'C';
    } else if(ioportid == GPIOD) {
 8002cea:	4b1f      	ldr	r3, [pc, #124]	; (8002d68 <_Z12portToStringP12stm32_gpio_tmPc+0x98>)
 8002cec:	4298      	cmp	r0, r3
 8002cee:	d02b      	beq.n	8002d48 <_Z12portToStringP12stm32_gpio_tmPc+0x78>
        result[1] = 'D';
    } else if(ioportid == GPIOE) {
 8002cf0:	4b1e      	ldr	r3, [pc, #120]	; (8002d6c <_Z12portToStringP12stm32_gpio_tmPc+0x9c>)
 8002cf2:	4298      	cmp	r0, r3
 8002cf4:	d022      	beq.n	8002d3c <_Z12portToStringP12stm32_gpio_tmPc+0x6c>
        result[1] = 'E';
    } else if(ioportid == GPIOF) {
 8002cf6:	4b1e      	ldr	r3, [pc, #120]	; (8002d70 <_Z12portToStringP12stm32_gpio_tmPc+0xa0>)
 8002cf8:	4298      	cmp	r0, r3
 8002cfa:	d028      	beq.n	8002d4e <_Z12portToStringP12stm32_gpio_tmPc+0x7e>
        result[1] = 'F';
    } else if(ioportid == GPIOG) {
 8002cfc:	4b1d      	ldr	r3, [pc, #116]	; (8002d74 <_Z12portToStringP12stm32_gpio_tmPc+0xa4>)
 8002cfe:	4298      	cmp	r0, r3
 8002d00:	d028      	beq.n	8002d54 <_Z12portToStringP12stm32_gpio_tmPc+0x84>
        result[1] = 'G';
    } else if(ioportid == GPIOH) {
 8002d02:	4b1d      	ldr	r3, [pc, #116]	; (8002d78 <_Z12portToStringP12stm32_gpio_tmPc+0xa8>)
 8002d04:	4298      	cmp	r0, r3
        result[1] = 'H';
 8002d06:	bf04      	itt	eq
 8002d08:	2348      	moveq	r3, #72	; 0x48
 8002d0a:	7053      	strbeq	r3, [r2, #1]
 8002d0c:	e001      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
        result[1] = 'B';
 8002d0e:	2342      	movs	r3, #66	; 0x42
 8002d10:	7053      	strb	r3, [r2, #1]
    }
    result[2] = ioportmask > 9 ? '1' : '0';
    result[3] = '0' + (ioportmask % 10);
 8002d12:	4b1a      	ldr	r3, [pc, #104]	; (8002d7c <_Z12portToStringP12stm32_gpio_tmPc+0xac>)
 8002d14:	bc10      	pop	{r4}
    result[3] = '0' + (ioportmask % 10);
 8002d16:	fba3 0301 	umull	r0, r3, r3, r1
 8002d1a:	08db      	lsrs	r3, r3, #3
 8002d1c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8002d20:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
    result[2] = ioportmask > 9 ? '1' : '0';
 8002d24:	2909      	cmp	r1, #9
    result[3] = '0' + (ioportmask % 10);
 8002d26:	f103 0330 	add.w	r3, r3, #48	; 0x30
    result[2] = ioportmask > 9 ? '1' : '0';
 8002d2a:	bf8c      	ite	hi
 8002d2c:	2131      	movhi	r1, #49	; 0x31
 8002d2e:	2130      	movls	r1, #48	; 0x30
    result[3] = '0' + (ioportmask % 10);
 8002d30:	70d3      	strb	r3, [r2, #3]
    result[2] = ioportmask > 9 ? '1' : '0';
 8002d32:	7091      	strb	r1, [r2, #2]
 8002d34:	4770      	bx	lr
        result[1] = 'A';
 8002d36:	2341      	movs	r3, #65	; 0x41
 8002d38:	7053      	strb	r3, [r2, #1]
 8002d3a:	e7ea      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
        result[1] = 'E';
 8002d3c:	2345      	movs	r3, #69	; 0x45
 8002d3e:	7053      	strb	r3, [r2, #1]
 8002d40:	e7e7      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
        result[1] = 'C';
 8002d42:	2343      	movs	r3, #67	; 0x43
 8002d44:	7053      	strb	r3, [r2, #1]
 8002d46:	e7e4      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
        result[1] = 'D';
 8002d48:	2344      	movs	r3, #68	; 0x44
 8002d4a:	7053      	strb	r3, [r2, #1]
 8002d4c:	e7e1      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
        result[1] = 'F';
 8002d4e:	2346      	movs	r3, #70	; 0x46
 8002d50:	7053      	strb	r3, [r2, #1]
 8002d52:	e7de      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
        result[1] = 'G';
 8002d54:	2347      	movs	r3, #71	; 0x47
 8002d56:	7053      	strb	r3, [r2, #1]
 8002d58:	e7db      	b.n	8002d12 <_Z12portToStringP12stm32_gpio_tmPc+0x42>
 8002d5a:	bf00      	nop
 8002d5c:	40020000 	.word	0x40020000
 8002d60:	40020400 	.word	0x40020400
 8002d64:	40020800 	.word	0x40020800
 8002d68:	40020c00 	.word	0x40020c00
 8002d6c:	40021000 	.word	0x40021000
 8002d70:	40021400 	.word	0x40021400
 8002d74:	40021800 	.word	0x40021800
 8002d78:	40021c00 	.word	0x40021c00
 8002d7c:	cccccccd 	.word	0xcccccccd

08002d80 <_ZN10chibios_rt16BaseStaticThreadILi256EE5startEm>:
     * @return                  A reference to the created thread with
     *                          reference counter set to one.
     *
     * @api
     */
    ThreadReference start(tprio_t prio) override {
 8002d80:	b500      	push	{lr}
 8002d82:	b083      	sub	sp, #12
      void _thd_start(void *arg);

      return ThreadReference(chThdCreateStatic(wa, sizeof(wa), prio,
                                               _thd_start, this));
 8002d84:	460a      	mov	r2, r1
 8002d86:	9000      	str	r0, [sp, #0]
 8002d88:	4b04      	ldr	r3, [pc, #16]	; (8002d9c <_ZN10chibios_rt16BaseStaticThreadILi256EE5startEm+0x1c>)
 8002d8a:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8002d8e:	3008      	adds	r0, #8
 8002d90:	f7fe ff7e 	bl	8001c90 <chThdCreateStatic>
    }
 8002d94:	b003      	add	sp, #12
 8002d96:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d9a:	bf00      	nop
 8002d9c:	08002cc1 	.word	0x08002cc1

08002da0 <_ZN19ButtonMonitorThread4mainEv>:
        : BaseStaticThread<256>() {
    _ioportid = ioportid;
    _ioportmask = ioportmask;
}

void ButtonMonitorThread::main(void) {
 8002da0:	b580      	push	{r7, lr}
    palSetPadMode(_ioportid, _ioportmask, PAL_MODE_INPUT_PULLUP);
 8002da2:	f8d0 11d4 	ldr.w	r1, [r0, #468]	; 0x1d4
 8002da6:	2501      	movs	r5, #1
void ButtonMonitorThread::main(void) {
 8002da8:	b084      	sub	sp, #16
 8002daa:	4604      	mov	r4, r0
    palSetPadMode(_ioportid, _ioportmask, PAL_MODE_INPUT_PULLUP);
 8002dac:	fa05 f101 	lsl.w	r1, r5, r1
 8002db0:	f8d0 01d0 	ldr.w	r0, [r0, #464]	; 0x1d0
 8002db4:	2220      	movs	r2, #32
 8002db6:	f7fe f9f3 	bl	80011a0 <_pal_lld_setgroupmode>
    char name[] = "btn_PXXX";
 8002dba:	4b22      	ldr	r3, [pc, #136]	; (8002e44 <_ZN19ButtonMonitorThread4mainEv+0xa4>)
 8002dbc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8002dc0:	ab01      	add	r3, sp, #4
 8002dc2:	c303      	stmia	r3!, {r0, r1}
    portToString(_ioportid, _ioportmask, name + 4);
 8002dc4:	f8d4 11d4 	ldr.w	r1, [r4, #468]	; 0x1d4
    char name[] = "btn_PXXX";
 8002dc8:	701a      	strb	r2, [r3, #0]
    portToString(_ioportid, _ioportmask, name + 4);
 8002dca:	f8d4 01d0 	ldr.w	r0, [r4, #464]	; 0x1d0
 8002dce:	aa02      	add	r2, sp, #8
 8002dd0:	f7ff ff7e 	bl	8002cd0 <_Z12portToStringP12stm32_gpio_tmPc>
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8002dd4:	4b1c      	ldr	r3, [pc, #112]	; (8002e48 <_ZN19ButtonMonitorThread4mainEv+0xa8>)
 8002dd6:	f8d4 11d4 	ldr.w	r1, [r4, #468]	; 0x1d4
 8002dda:	699b      	ldr	r3, [r3, #24]
 8002ddc:	f8d4 21d0 	ldr.w	r2, [r4, #464]	; 0x1d0
 8002de0:	a801      	add	r0, sp, #4
 8002de2:	6198      	str	r0, [r3, #24]
        //if(_function) _function();
        while(!palReadPad(_ioportid, _ioportmask)) {
            // Wait for the button to be released
            sleep(TIME_MS2I(5));
        }
        pressed = false;
 8002de4:	2600      	movs	r6, #0
        while(palReadPad(_ioportid, _ioportmask)) {
 8002de6:	6913      	ldr	r3, [r2, #16]
 8002de8:	40cb      	lsrs	r3, r1
 8002dea:	07df      	lsls	r7, r3, #31
 8002dec:	d50a      	bpl.n	8002e04 <_ZN19ButtonMonitorThread4mainEv+0x64>
      chThdSleep(interval);
 8002dee:	2032      	movs	r0, #50	; 0x32
 8002df0:	f7fe ffee 	bl	8001dd0 <chThdSleep>
 8002df4:	f8d4 21d0 	ldr.w	r2, [r4, #464]	; 0x1d0
 8002df8:	f8d4 11d4 	ldr.w	r1, [r4, #468]	; 0x1d4
 8002dfc:	6913      	ldr	r3, [r2, #16]
 8002dfe:	40cb      	lsrs	r3, r1
 8002e00:	07df      	lsls	r7, r3, #31
 8002e02:	d4f4      	bmi.n	8002dee <_ZN19ButtonMonitorThread4mainEv+0x4e>
        while(!palReadPad(_ioportid, _ioportmask)) {
 8002e04:	6913      	ldr	r3, [r2, #16]
        counter++;
 8002e06:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
        toggle = !toggle;
 8002e0a:	f894 71d9 	ldrb.w	r7, [r4, #473]	; 0x1d9
        pressed = true;
 8002e0e:	f884 51d8 	strb.w	r5, [r4, #472]	; 0x1d8
        counter++;
 8002e12:	3001      	adds	r0, #1
        while(!palReadPad(_ioportid, _ioportmask)) {
 8002e14:	40cb      	lsrs	r3, r1
        toggle = !toggle;
 8002e16:	f087 0701 	eor.w	r7, r7, #1
        counter++;
 8002e1a:	f8c4 01dc 	str.w	r0, [r4, #476]	; 0x1dc
        while(!palReadPad(_ioportid, _ioportmask)) {
 8002e1e:	07d8      	lsls	r0, r3, #31
        toggle = !toggle;
 8002e20:	f884 71d9 	strb.w	r7, [r4, #473]	; 0x1d9
        while(!palReadPad(_ioportid, _ioportmask)) {
 8002e24:	d40a      	bmi.n	8002e3c <_ZN19ButtonMonitorThread4mainEv+0x9c>
 8002e26:	2032      	movs	r0, #50	; 0x32
 8002e28:	f7fe ffd2 	bl	8001dd0 <chThdSleep>
 8002e2c:	f8d4 21d0 	ldr.w	r2, [r4, #464]	; 0x1d0
 8002e30:	f8d4 11d4 	ldr.w	r1, [r4, #468]	; 0x1d4
 8002e34:	6913      	ldr	r3, [r2, #16]
 8002e36:	40cb      	lsrs	r3, r1
 8002e38:	07db      	lsls	r3, r3, #31
 8002e3a:	d5f4      	bpl.n	8002e26 <_ZN19ButtonMonitorThread4mainEv+0x86>
        pressed = false;
 8002e3c:	f884 61d8 	strb.w	r6, [r4, #472]	; 0x1d8
    while(true) {
 8002e40:	e7d1      	b.n	8002de6 <_ZN19ButtonMonitorThread4mainEv+0x46>
 8002e42:	bf00      	nop
 8002e44:	08003768 	.word	0x08003768
 8002e48:	20000980 	.word	0x20000980
 8002e4c:	00000000 	.word	0x00000000

08002e50 <_ZN19ButtonMonitorThreadC1EP12stm32_gpio_tm>:
ButtonMonitorThread::ButtonMonitorThread(ioportid_t ioportid, ioportmask_t ioportmask)
 8002e50:	b538      	push	{r3, r4, r5, lr}
 8002e52:	460d      	mov	r5, r1
 8002e54:	4614      	mov	r4, r2
        : BaseStaticThread<256>() {
 8002e56:	2100      	movs	r1, #0
 8002e58:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 8002e5c:	f000 f8fc 	bl	8003058 <memset>
 8002e60:	2200      	movs	r2, #0
 8002e62:	4906      	ldr	r1, [pc, #24]	; (8002e7c <_ZN19ButtonMonitorThreadC1EP12stm32_gpio_tm+0x2c>)
    _ioportid = ioportid;
 8002e64:	f8c0 51d0 	str.w	r5, [r0, #464]	; 0x1d0
    _ioportmask = ioportmask;
 8002e68:	f8c0 41d4 	str.w	r4, [r0, #468]	; 0x1d4
        : BaseStaticThread<256>() {
 8002e6c:	6001      	str	r1, [r0, #0]
 8002e6e:	f880 21d8 	strb.w	r2, [r0, #472]	; 0x1d8
 8002e72:	f880 21d9 	strb.w	r2, [r0, #473]	; 0x1d9
 8002e76:	f8c0 21dc 	str.w	r2, [r0, #476]	; 0x1dc
}
 8002e7a:	bd38      	pop	{r3, r4, r5, pc}
 8002e7c:	0800377c 	.word	0x0800377c

08002e80 <_Z10shellStartv>:
    shellCommands
};

static THD_WORKING_AREA(waShell, 1024);

void shellStart(void) {
 8002e80:	b510      	push	{r4, lr}
    palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
 8002e82:	4c11      	ldr	r4, [pc, #68]	; (8002ec8 <_Z10shellStartv+0x48>)
void shellStart(void) {
 8002e84:	b082      	sub	sp, #8
    palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
 8002e86:	4620      	mov	r0, r4
 8002e88:	f240 3282 	movw	r2, #898	; 0x382
 8002e8c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002e90:	f7fe f986 	bl	80011a0 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
 8002e94:	f240 3282 	movw	r2, #898	; 0x382
 8002e98:	4620      	mov	r0, r4
 8002e9a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8002e9e:	f7fe f97f 	bl	80011a0 <_pal_lld_setgroupmode>
    sdStart(&SD1, &shellSerialConfig);
 8002ea2:	490a      	ldr	r1, [pc, #40]	; (8002ecc <_Z10shellStartv+0x4c>)
 8002ea4:	480a      	ldr	r0, [pc, #40]	; (8002ed0 <_Z10shellStartv+0x50>)
 8002ea6:	f7fe f84b 	bl	8000f40 <sdStart>
    shellInit();
 8002eaa:	f7ff fce1 	bl	8002870 <shellInit>
    
    thread_t *shellThreadRef = chThdCreateStatic(
        waShell, sizeof(waShell), NORMALPRIO,
        shellThread, (void*) &shellConfig);
 8002eae:	4b09      	ldr	r3, [pc, #36]	; (8002ed4 <_Z10shellStartv+0x54>)
 8002eb0:	9300      	str	r3, [sp, #0]
 8002eb2:	2280      	movs	r2, #128	; 0x80
 8002eb4:	4b08      	ldr	r3, [pc, #32]	; (8002ed8 <_Z10shellStartv+0x58>)
 8002eb6:	4809      	ldr	r0, [pc, #36]	; (8002edc <_Z10shellStartv+0x5c>)
 8002eb8:	f44f 6199 	mov.w	r1, #1224	; 0x4c8
 8002ebc:	f7fe fee8 	bl	8001c90 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->name = name;
 8002ec0:	4b07      	ldr	r3, [pc, #28]	; (8002ee0 <_Z10shellStartv+0x60>)
 8002ec2:	6183      	str	r3, [r0, #24]
    chRegSetThreadNameX(shellThreadRef, "shell");
 8002ec4:	b002      	add	sp, #8
 8002ec6:	bd10      	pop	{r4, pc}
 8002ec8:	40020000 	.word	0x40020000
 8002ecc:	20000800 	.word	0x20000800
 8002ed0:	2000082c 	.word	0x2000082c
 8002ed4:	0800378c 	.word	0x0800378c
 8002ed8:	08002921 	.word	0x08002921
 8002edc:	20000a68 	.word	0x20000a68
 8002ee0:	08003784 	.word	0x08003784
	...

08002ef0 <_ZL9cmd_helloP20BaseSequentialStreamiPPc>:
#include "serial_shell_commands.hpp"

static void cmd_hello(BaseSequentialStream *chp, int argc, char *argv[]) {
    (void)argv;
    if (argc > 0) {
 8002ef0:	2900      	cmp	r1, #0
 8002ef2:	dd02      	ble.n	8002efa <_ZL9cmd_helloP20BaseSequentialStreamiPPc+0xa>
        chprintf(chp, "Usage: hello\r\n");
 8002ef4:	4902      	ldr	r1, [pc, #8]	; (8002f00 <_ZL9cmd_helloP20BaseSequentialStreamiPPc+0x10>)
 8002ef6:	f7ff bc7b 	b.w	80027f0 <chprintf>
        return;
    }
    chprintf(chp, "Hello World from ChibiOS!\r\n");
 8002efa:	4902      	ldr	r1, [pc, #8]	; (8002f04 <_ZL9cmd_helloP20BaseSequentialStreamiPPc+0x14>)
 8002efc:	f7ff bc78 	b.w	80027f0 <chprintf>
 8002f00:	08003794 	.word	0x08003794
 8002f04:	080037a4 	.word	0x080037a4
	...

08002f10 <main>:
#include "led.hpp"
#include "serial_shell.hpp"

using namespace chibios_rt;

int main(void) {
 8002f10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002f14:	b083      	sub	sp, #12
    halInit();
 8002f16:	f7fd fdd3 	bl	8000ac0 <halInit>
      chSysInit();
 8002f1a:	f7fe fc09 	bl	8001730 <chSysInit>
    System::init();

    palSetPadMode(GPIOA, 6, PAL_MODE_OUTPUT_PUSHPULL);
 8002f1e:	2201      	movs	r2, #1
 8002f20:	2140      	movs	r1, #64	; 0x40
 8002f22:	483c      	ldr	r0, [pc, #240]	; (8003014 <main+0x104>)
                                               _thd_start, this));
 8002f24:	4f3c      	ldr	r7, [pc, #240]	; (8003018 <main+0x108>)
 8002f26:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8003024 <main+0x114>
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
            LED_D2_OFF;
            LED_D3_ON;
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
        } else {
            LED_D2_ON;
 8002f2a:	4d3a      	ldr	r5, [pc, #232]	; (8003014 <main+0x104>)
    palSetPadMode(GPIOA, 6, PAL_MODE_OUTPUT_PUSHPULL);
 8002f2c:	f7fe f938 	bl	80011a0 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOA, 7, PAL_MODE_OUTPUT_PUSHPULL);
 8002f30:	2201      	movs	r2, #1
 8002f32:	2180      	movs	r1, #128	; 0x80
 8002f34:	4837      	ldr	r0, [pc, #220]	; (8003014 <main+0x104>)
 8002f36:	f7fe f933 	bl	80011a0 <_pal_lld_setgroupmode>
 8002f3a:	4b38      	ldr	r3, [pc, #224]	; (800301c <main+0x10c>)
 8002f3c:	9300      	str	r3, [sp, #0]
 8002f3e:	f103 0008 	add.w	r0, r3, #8
 8002f42:	2280      	movs	r2, #128	; 0x80
 8002f44:	4b36      	ldr	r3, [pc, #216]	; (8003020 <main+0x110>)
 8002f46:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8002f4a:	f7fe fea1 	bl	8001c90 <chThdCreateStatic>
 8002f4e:	4b34      	ldr	r3, [pc, #208]	; (8003020 <main+0x110>)
 8002f50:	9700      	str	r7, [sp, #0]
 8002f52:	2280      	movs	r2, #128	; 0x80
 8002f54:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8002f58:	f107 0008 	add.w	r0, r7, #8
 8002f5c:	f7fe fe98 	bl	8001c90 <chThdCreateStatic>
    shellStart();
 8002f60:	f7ff ff8e 	bl	8002e80 <_Z10shellStartv>
 8002f64:	e01f      	b.n	8002fa6 <main+0x96>
            LED_D2_ON;
 8002f66:	f8a5 b01a 	strh.w	fp, [r5, #26]
            LED_D3_OFF;
 8002f6a:	f8a5 a018 	strh.w	sl, [r5, #24]
      chThdSleep(interval);
 8002f6e:	f7fe ff2f 	bl	8001dd0 <chThdSleep>
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
 8002f72:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
            LED_D2_OFF;
 8002f76:	f8a5 b018 	strh.w	fp, [r5, #24]
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
 8002f7a:	fba8 1203 	umull	r1, r2, r8, r3
 8002f7e:	0852      	lsrs	r2, r2, #1
 8002f80:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8002f84:	1a9b      	subs	r3, r3, r2
 8002f86:	fb03 4404 	mla	r4, r3, r4, r4
            LED_D3_ON;
 8002f8a:	f8a5 a01a 	strh.w	sl, [r5, #26]
            LED_D3_ON;
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
            LED_D2_OFF;
            LED_D3_OFF;
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
 8002f8e:	f240 30e7 	movw	r0, #999	; 0x3e7
 8002f92:	2100      	movs	r1, #0
 8002f94:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8002f98:	2300      	movs	r3, #0
 8002f9a:	fbe6 0104 	umlal	r0, r1, r6, r4
 8002f9e:	f7fd f9ab 	bl	80002f8 <__aeabi_uldivmod>
 8002fa2:	f7fe ff15 	bl	8001dd0 <chThdSleep>
 8002fa6:	f8d7 31dc 	ldr.w	r3, [r7, #476]	; 0x1dc
 8002faa:	fba8 1203 	umull	r1, r2, r8, r3
 8002fae:	0852      	lsrs	r2, r2, #1
 8002fb0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8002fb4:	1a9b      	subs	r3, r3, r2
 8002fb6:	2464      	movs	r4, #100	; 0x64
 8002fb8:	fb03 4304 	mla	r3, r3, r4, r4
 8002fbc:	f242 7610 	movw	r6, #10000	; 0x2710
 8002fc0:	f240 30e7 	movw	r0, #999	; 0x3e7
 8002fc4:	2100      	movs	r1, #0
 8002fc6:	fbe6 0103 	umlal	r0, r1, r6, r3
 8002fca:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8002fce:	2300      	movs	r3, #0
 8002fd0:	f7fd f992 	bl	80002f8 <__aeabi_uldivmod>
        if(buttonK0.toggle) {
 8002fd4:	4b11      	ldr	r3, [pc, #68]	; (800301c <main+0x10c>)
 8002fd6:	f893 31d9 	ldrb.w	r3, [r3, #473]	; 0x1d9
            LED_D2_ON;
 8002fda:	f04f 0b40 	mov.w	fp, #64	; 0x40
            LED_D3_OFF;
 8002fde:	f04f 0a80 	mov.w	sl, #128	; 0x80
        if(buttonK0.toggle) {
 8002fe2:	2b00      	cmp	r3, #0
 8002fe4:	d1bf      	bne.n	8002f66 <main+0x56>
            LED_D3_ON;
 8002fe6:	f04f 0a80 	mov.w	sl, #128	; 0x80
            LED_D2_ON;
 8002fea:	f8a5 b01a 	strh.w	fp, [r5, #26]
            LED_D3_ON;
 8002fee:	f8a5 a01a 	strh.w	sl, [r5, #26]
 8002ff2:	f7fe feed 	bl	8001dd0 <chThdSleep>
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
 8002ff6:	f8d7 21dc 	ldr.w	r2, [r7, #476]	; 0x1dc
            LED_D2_OFF;
 8002ffa:	f8a5 b018 	strh.w	fp, [r5, #24]
            BaseThread::sleep(TIME_MS2I((1 + buttonK1.counter % 3) * 100));
 8002ffe:	fba8 1302 	umull	r1, r3, r8, r2
 8003002:	085b      	lsrs	r3, r3, #1
 8003004:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003008:	1ad3      	subs	r3, r2, r3
 800300a:	fb03 4404 	mla	r4, r3, r4, r4
            LED_D3_OFF;
 800300e:	f8a5 a018 	strh.w	sl, [r5, #24]
 8003012:	e7bc      	b.n	8002f8e <main+0x7e>
 8003014:	40020000 	.word	0x40020000
 8003018:	20001110 	.word	0x20001110
 800301c:	20000f30 	.word	0x20000f30
 8003020:	08002cc1 	.word	0x08002cc1
 8003024:	aaaaaaab 	.word	0xaaaaaaab
	...

08003030 <_GLOBAL__sub_I_main>:
        }
    }
    return 0;
}
 8003030:	b510      	push	{r4, lr}
    bool toggle = false;
    uint32_t counter = 0;
    ButtonMonitorThread(ioportid_t ioportid, ioportmask_t ioportmask);
};

static ButtonMonitorThread buttonK0(GPIOE, 4);
 8003032:	4c06      	ldr	r4, [pc, #24]	; (800304c <_GLOBAL__sub_I_main+0x1c>)
 8003034:	4806      	ldr	r0, [pc, #24]	; (8003050 <_GLOBAL__sub_I_main+0x20>)
 8003036:	4621      	mov	r1, r4
 8003038:	2204      	movs	r2, #4
 800303a:	f7ff ff09 	bl	8002e50 <_ZN19ButtonMonitorThreadC1EP12stm32_gpio_tm>
static ButtonMonitorThread buttonK1(GPIOE, 3);
 800303e:	4621      	mov	r1, r4
 8003040:	2203      	movs	r2, #3
 8003042:	4804      	ldr	r0, [pc, #16]	; (8003054 <_GLOBAL__sub_I_main+0x24>)
 8003044:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8003048:	f7ff bf02 	b.w	8002e50 <_ZN19ButtonMonitorThreadC1EP12stm32_gpio_tm>
 800304c:	40021000 	.word	0x40021000
 8003050:	20000f30 	.word	0x20000f30
 8003054:	20001110 	.word	0x20001110

08003058 <memset>:
 8003058:	b4f0      	push	{r4, r5, r6, r7}
 800305a:	0786      	lsls	r6, r0, #30
 800305c:	d043      	beq.n	80030e6 <memset+0x8e>
 800305e:	1e54      	subs	r4, r2, #1
 8003060:	2a00      	cmp	r2, #0
 8003062:	d03e      	beq.n	80030e2 <memset+0x8a>
 8003064:	b2ca      	uxtb	r2, r1
 8003066:	4603      	mov	r3, r0
 8003068:	e002      	b.n	8003070 <memset+0x18>
 800306a:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 800306e:	d338      	bcc.n	80030e2 <memset+0x8a>
 8003070:	f803 2b01 	strb.w	r2, [r3], #1
 8003074:	079d      	lsls	r5, r3, #30
 8003076:	d1f8      	bne.n	800306a <memset+0x12>
 8003078:	2c03      	cmp	r4, #3
 800307a:	d92b      	bls.n	80030d4 <memset+0x7c>
 800307c:	b2cd      	uxtb	r5, r1
 800307e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8003082:	2c0f      	cmp	r4, #15
 8003084:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8003088:	d916      	bls.n	80030b8 <memset+0x60>
 800308a:	f1a4 0710 	sub.w	r7, r4, #16
 800308e:	093f      	lsrs	r7, r7, #4
 8003090:	f103 0620 	add.w	r6, r3, #32
 8003094:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8003098:	f103 0210 	add.w	r2, r3, #16
 800309c:	e942 5504 	strd	r5, r5, [r2, #-16]
 80030a0:	e942 5502 	strd	r5, r5, [r2, #-8]
 80030a4:	3210      	adds	r2, #16
 80030a6:	42b2      	cmp	r2, r6
 80030a8:	d1f8      	bne.n	800309c <memset+0x44>
 80030aa:	f004 040f 	and.w	r4, r4, #15
 80030ae:	3701      	adds	r7, #1
 80030b0:	2c03      	cmp	r4, #3
 80030b2:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 80030b6:	d90d      	bls.n	80030d4 <memset+0x7c>
 80030b8:	461e      	mov	r6, r3
 80030ba:	4622      	mov	r2, r4
 80030bc:	3a04      	subs	r2, #4
 80030be:	2a03      	cmp	r2, #3
 80030c0:	f846 5b04 	str.w	r5, [r6], #4
 80030c4:	d8fa      	bhi.n	80030bc <memset+0x64>
 80030c6:	1f22      	subs	r2, r4, #4
 80030c8:	f022 0203 	bic.w	r2, r2, #3
 80030cc:	3204      	adds	r2, #4
 80030ce:	4413      	add	r3, r2
 80030d0:	f004 0403 	and.w	r4, r4, #3
 80030d4:	b12c      	cbz	r4, 80030e2 <memset+0x8a>
 80030d6:	b2c9      	uxtb	r1, r1
 80030d8:	441c      	add	r4, r3
 80030da:	f803 1b01 	strb.w	r1, [r3], #1
 80030de:	429c      	cmp	r4, r3
 80030e0:	d1fb      	bne.n	80030da <memset+0x82>
 80030e2:	bcf0      	pop	{r4, r5, r6, r7}
 80030e4:	4770      	bx	lr
 80030e6:	4614      	mov	r4, r2
 80030e8:	4603      	mov	r3, r0
 80030ea:	e7c5      	b.n	8003078 <memset+0x20>

080030ec <strchr>:
 80030ec:	b2c9      	uxtb	r1, r1
 80030ee:	f000 0303 	and.w	r3, r0, #3
 80030f2:	2900      	cmp	r1, #0
 80030f4:	d043      	beq.n	800317e <strchr+0x92>
 80030f6:	b17b      	cbz	r3, 8003118 <strchr+0x2c>
 80030f8:	7803      	ldrb	r3, [r0, #0]
 80030fa:	2b00      	cmp	r3, #0
 80030fc:	d067      	beq.n	80031ce <strchr+0xe2>
 80030fe:	4299      	cmp	r1, r3
 8003100:	d03c      	beq.n	800317c <strchr+0x90>
 8003102:	1c43      	adds	r3, r0, #1
 8003104:	e005      	b.n	8003112 <strchr+0x26>
 8003106:	f813 2b01 	ldrb.w	r2, [r3], #1
 800310a:	2a00      	cmp	r2, #0
 800310c:	d05d      	beq.n	80031ca <strchr+0xde>
 800310e:	428a      	cmp	r2, r1
 8003110:	d034      	beq.n	800317c <strchr+0x90>
 8003112:	079a      	lsls	r2, r3, #30
 8003114:	4618      	mov	r0, r3
 8003116:	d1f6      	bne.n	8003106 <strchr+0x1a>
 8003118:	b470      	push	{r4, r5, r6}
 800311a:	6804      	ldr	r4, [r0, #0]
 800311c:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8003120:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8003124:	ea86 0504 	eor.w	r5, r6, r4
 8003128:	f1a5 3301 	sub.w	r3, r5, #16843009	; 0x1010101
 800312c:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 8003130:	ea23 0305 	bic.w	r3, r3, r5
 8003134:	ea22 0204 	bic.w	r2, r2, r4
 8003138:	4313      	orrs	r3, r2
 800313a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800313e:	d10f      	bne.n	8003160 <strchr+0x74>
 8003140:	f850 4f04 	ldr.w	r4, [r0, #4]!
 8003144:	ea84 0506 	eor.w	r5, r4, r6
 8003148:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
 800314c:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
 8003150:	ea22 0205 	bic.w	r2, r2, r5
 8003154:	ea23 0304 	bic.w	r3, r3, r4
 8003158:	4313      	orrs	r3, r2
 800315a:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800315e:	d0ef      	beq.n	8003140 <strchr+0x54>
 8003160:	7803      	ldrb	r3, [r0, #0]
 8003162:	b143      	cbz	r3, 8003176 <strchr+0x8a>
 8003164:	4299      	cmp	r1, r3
 8003166:	d102      	bne.n	800316e <strchr+0x82>
 8003168:	e006      	b.n	8003178 <strchr+0x8c>
 800316a:	428b      	cmp	r3, r1
 800316c:	d004      	beq.n	8003178 <strchr+0x8c>
 800316e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8003172:	2b00      	cmp	r3, #0
 8003174:	d1f9      	bne.n	800316a <strchr+0x7e>
 8003176:	4618      	mov	r0, r3
 8003178:	bc70      	pop	{r4, r5, r6}
 800317a:	4770      	bx	lr
 800317c:	4770      	bx	lr
 800317e:	b15b      	cbz	r3, 8003198 <strchr+0xac>
 8003180:	7803      	ldrb	r3, [r0, #0]
 8003182:	2b00      	cmp	r3, #0
 8003184:	d0fa      	beq.n	800317c <strchr+0x90>
 8003186:	1c43      	adds	r3, r0, #1
 8003188:	e003      	b.n	8003192 <strchr+0xa6>
 800318a:	7802      	ldrb	r2, [r0, #0]
 800318c:	3301      	adds	r3, #1
 800318e:	2a00      	cmp	r2, #0
 8003190:	d0f4      	beq.n	800317c <strchr+0x90>
 8003192:	0799      	lsls	r1, r3, #30
 8003194:	4618      	mov	r0, r3
 8003196:	d1f8      	bne.n	800318a <strchr+0x9e>
 8003198:	6802      	ldr	r2, [r0, #0]
 800319a:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 800319e:	ea23 0302 	bic.w	r3, r3, r2
 80031a2:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80031a6:	d108      	bne.n	80031ba <strchr+0xce>
 80031a8:	f850 2f04 	ldr.w	r2, [r0, #4]!
 80031ac:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 80031b0:	ea23 0302 	bic.w	r3, r3, r2
 80031b4:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 80031b8:	d0f6      	beq.n	80031a8 <strchr+0xbc>
 80031ba:	7803      	ldrb	r3, [r0, #0]
 80031bc:	2b00      	cmp	r3, #0
 80031be:	d0dd      	beq.n	800317c <strchr+0x90>
 80031c0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80031c4:	2b00      	cmp	r3, #0
 80031c6:	d1fb      	bne.n	80031c0 <strchr+0xd4>
 80031c8:	4770      	bx	lr
 80031ca:	4610      	mov	r0, r2
 80031cc:	4770      	bx	lr
 80031ce:	4618      	mov	r0, r3
 80031d0:	4770      	bx	lr
 80031d2:	bf00      	nop

080031d4 <strpbrk>:
 80031d4:	b430      	push	{r4, r5}
 80031d6:	7804      	ldrb	r4, [r0, #0]
 80031d8:	b1dc      	cbz	r4, 8003212 <strpbrk+0x3e>
 80031da:	780d      	ldrb	r5, [r1, #0]
 80031dc:	b19d      	cbz	r5, 8003206 <strpbrk+0x32>
 80031de:	42ac      	cmp	r4, r5
 80031e0:	d00f      	beq.n	8003202 <strpbrk+0x2e>
 80031e2:	460a      	mov	r2, r1
 80031e4:	e001      	b.n	80031ea <strpbrk+0x16>
 80031e6:	429c      	cmp	r4, r3
 80031e8:	d00b      	beq.n	8003202 <strpbrk+0x2e>
 80031ea:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80031ee:	2b00      	cmp	r3, #0
 80031f0:	d1f9      	bne.n	80031e6 <strpbrk+0x12>
 80031f2:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80031f6:	2c00      	cmp	r4, #0
 80031f8:	d1f0      	bne.n	80031dc <strpbrk+0x8>
 80031fa:	7813      	ldrb	r3, [r2, #0]
 80031fc:	2b00      	cmp	r3, #0
 80031fe:	bf08      	it	eq
 8003200:	2000      	moveq	r0, #0
 8003202:	bc30      	pop	{r4, r5}
 8003204:	4770      	bx	lr
 8003206:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800320a:	460a      	mov	r2, r1
 800320c:	2c00      	cmp	r4, #0
 800320e:	d1e5      	bne.n	80031dc <strpbrk+0x8>
 8003210:	e7f3      	b.n	80031fa <strpbrk+0x26>
 8003212:	4620      	mov	r0, r4
 8003214:	e7f5      	b.n	8003202 <strpbrk+0x2e>
 8003216:	bf00      	nop

08003218 <strspn>:
 8003218:	b470      	push	{r4, r5, r6}
 800321a:	7804      	ldrb	r4, [r0, #0]
 800321c:	b1a4      	cbz	r4, 8003248 <strspn+0x30>
 800321e:	780d      	ldrb	r5, [r1, #0]
 8003220:	4606      	mov	r6, r0
 8003222:	b14d      	cbz	r5, 8003238 <strspn+0x20>
 8003224:	42a5      	cmp	r5, r4
 8003226:	d00a      	beq.n	800323e <strspn+0x26>
 8003228:	460a      	mov	r2, r1
 800322a:	e001      	b.n	8003230 <strspn+0x18>
 800322c:	42a3      	cmp	r3, r4
 800322e:	d006      	beq.n	800323e <strspn+0x26>
 8003230:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003234:	2b00      	cmp	r3, #0
 8003236:	d1f9      	bne.n	800322c <strspn+0x14>
 8003238:	1b80      	subs	r0, r0, r6
 800323a:	bc70      	pop	{r4, r5, r6}
 800323c:	4770      	bx	lr
 800323e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8003242:	2c00      	cmp	r4, #0
 8003244:	d1ed      	bne.n	8003222 <strspn+0xa>
 8003246:	e7f7      	b.n	8003238 <strspn+0x20>
 8003248:	4620      	mov	r0, r4
 800324a:	e7f6      	b.n	800323a <strspn+0x22>
